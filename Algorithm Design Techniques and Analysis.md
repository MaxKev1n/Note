算法需满足的4个性质：

* 输入：零个或多个外部量作为输出
* 输出：至少产生一个量作为输出
* 确定性：组成算法的每条指令都是清晰、无歧义的
* 有限性：每条指令的执行次数有限，执行每条指令的时间也有限



算法的复杂度：算法运行时需要耗费计算机资源的量，可以分为时间复杂度和空间复杂度。

依赖于三个方面：

1. 待求解问题的规模
2. 算法的输入
3. 算法本身

时间复杂度的具体化：假设计算机提供k种元运算，分别记为$O_1, O_2,...,O_k$。元运算$O_i$每执行一次需要的时间为$t_i$，对于给定的算法A，已经用到的元运算$O_i$的执行次数为$e_i$，很显然$T(n,I)=\sum_{i = 1}^k t_ie_i(n,I)$。**通常可以考虑三种情形下的时间复杂度：最坏情形、最好情形以及平均情形**。

------

##### 渐进分析（Asymptotic Analysis）

对于T(n)，当n单调递增并趋于$\infty$时，T(n)也是单调增加并趋于$\infty$。为此，如果存在一个T'(n)，使得n$\to \infty$时有$(T(n)-T'(n))/T(n) \to 0$，就称T'(n)时T(n)当$n\to \infty$的渐近性态，或称T'(n)是给定算法在$n\to \infty$时的渐近复杂度。显然，T'(n)不是唯一的。我们可以尽可能的选择简单的T'(n)，然后使用T'(n)来替代T(n)作为$n\to \infty$的复杂度度量。

---

##### 4种阶：$O, \Omega, \Theta, o$

定义1 ($O$)：如果存在正的常数$C$和自然数$n_0$，使得当 $n≥n_0$时，有$f(n)≤C·g(n)$，则称函数$f (n)$ 在n充分大时有上有界，且g(n) 是它的一个上界，记做$f (n) =  O(g(n))$ ，并称$f (n)$ 的阶不高于$g(n)$ 的阶。

* 在进行阶的运算时，<u>常系数</u>、<u>低的阶</u>以及<u>常数项</u>可以忽略。

* 根据$O$的定义，得到的是在问题规模充分大时，算法 复杂度的一个上界。上界的阶<u>越低</u>则评估越有价值。

* * $O( f ) + O(g) = O(max( f , g))$
  *  $O( f )·O(g) = O( f·g)$
  *  $O(C·f (n)) = O(f (n))$
  * $f = O( f )$



定义2($\Omega$)： 如果存在正的常数$C$ 和自然数$n_0$ ，使得当$n ≥ n_0$时， 有$f(n)≥C·g(n)$，则称函数$f(n)$在n充分大时有下有界，且$g(n)$是它的一个下界，记做$f(n) =\Omega (g(n))$ ，并称$f(n)$的阶不低于$g(n)$的阶。

* 下界的阶越高，则评估精度越高，也就越有价值



定义3($\Theta$)：$f(n) = \Theta(g(n))$，当且仅当$f(n)=O(g(n))$，且$f(n)=\Omega(g(n))$，称$f(n)$和$g(n)$是同阶。

定义4($o$) ：对于任意给定的$\epsilon>0$ ，存在正整数$n_0$ ，使得当$n ≥ n_0$ 时，有$f(n)/g(n)≤\epsilon$ ，则称函数$f(n)$在n充分大时的阶比$g(n)$低，记为$f(n)=o(g(n))$。

-------

如何计算算法的时间复杂度：

1. 计算迭代次数：计算算法的迭代次数通常可以作为算法运行时间的指示器。使用计算迭代次数的技术来分析算法的时间复杂度时，一般仅需考虑最深层次的迭代
2. 使用递归方程
3. 频度分析

快速排序：以待排序数组的首元素作为基准元素，将待排序数组分成左右两个子数组。使得左边子数组中的元素都小于等于基准元素；右边子数组中的元素都大于等于基准元素。左右子数组交替排序。

-----

* 如果$f=O(g)$且$g=O(h)$，那么$f=O(h)$
* 如果$f=\Omega(g)$且$g=\Omega(h)$，那么$f=\Omega(h)$
* 如果$f=\Theta(g)$且$g=\Theta(h)$，那么$f=\Theta(h)$
* 假设$f$和$g$是两个函数，若对于另外某个函数$h$，有$f=O(h)$和$g=O(h)$，那么$f+g=O(h)$
* 假设$f$和$g$是两个函数（取非负值），且$g=O(f)$。那么，$f+g=\Theta(f)$
* 设$f$为$d$阶多项式，其中系数$a_d$为正，那么$f=O(n^d)$
* 对于所有$b>1$和所有$x>0$，有$log_bn=O(n^x)$
* 对每个$r>1$和每个$d>0$，有$n^d=O(r^n)$

------

#### 递归方程求解

* 常系数线性同质递归方程

  $T(n)=a_1T(n-1)=a_2T(n-2)+...+a_kT(n-k)$称为k阶常系数线性同质递归方程。其特征方程为：$x^k=a_1x^{k-1}+a_2x^{k-2}+...+a_k \to x^k-a_1x^{k-1}-a_2x^{k-2}-...-a_k=0$

  对于一阶情形：$T(n)=aT(n-1)=a^2T(n-1)=...=a^nT(0)$

  对于二阶情形：$T(n)=\left\{\begin{aligned}
  c_1*x_1^n+c_2*x_2^n,x_1 \neq x_2\\ 
  c_1*r^n+c_2*n*r^n,x_1=x_2=r
  \end{aligned}
  \right.$

* 非同质递归方程



**Master定理**：设$a\geq 1,b >1$为阐述。$s(n)$为一给定的函数，$T(n)$递归定义如下：$T(n)=a*T(n/b)+s(n)$并且$T(n)$有适当的初始值。那么，当n充分大时，有：

1. 若存在$\varepsilon >0$，使得$s(n)=O(n^{log_b^a-\varepsilon})$成立，那么有$T(n)=\Theta(n^{log_b^a})$
2. 若$s(n)=\Theta(n^{log_b^a})$，呢么$T(n)=\Theta(n^{log_b^a}*logn)$
3. 若存在$\varepsilon >0$，使得$s(n)=\Omega(n^{log_b^a+\varepsilon})$成立，并且存在$c<1$，使得$a*s(n/b)\leq c*s(n)$，那么有$T(n)=\Theta(s(n))$

-------

### 堆

**堆**：堆是一个几乎完全的二叉树，每个节点都满足这样的特性，任一父节点的键值不小于子节点的键值

堆的基本操作：
* make-heap(A)：从数组A创建堆
* insert(H, x)：插入元素x到堆H中
* delete(H, i)：删除堆H的第i项
* delete-max(H)：从非空堆H中删除最大键值并返回数据项



**辅助运算Sift-up（向上调整）**：

* 若某个结点H[i]的键值大于其父节点的键值，就违背了堆的特性，需要进行调整
* 调整方法：上移
* 沿着H[i]到根节点的唯一一条路径，将H[i]移动到合适的位置上：比较H[i]及其父节点H[|i/2|]的键值，若key(H[i]) > key(H[|i/2|])，则将两者进行交换，直至达到合适的位置

---

### 不相交集

假设有n个元素，被分成若干个集合并分别命名。事实上，每个子集可以用树表示，除根节点外，每个节点都有指针指向父节点。用根节点表示集合的名字。

- FIND(x)：寻找包含元素x的集合的名字
- UNION(x, y)：将包含元素x和y的两个集合合并，重命名



记root(x)为包含元素x的树的根，则FIND(x)找到root(x)。

执行合并UNION(x, y)时，首先依据x找到root(x),记为u,依据y找到root(y)，记为v；然后，将u指向v。

目标：降低树的高度。措施：Rank Heuristic。

1. 给每个树的根节点定义一个秩(rank，标量)，表示该树的高度。
2. 在执行UNION(x, y) ，首先找到u=root(x)，v=root(y)。
3. 然后比较rank(u)和rank(v) 
4. * 若rank(u) = rank(v)，则使u指向v，v成为u的父亲，同时rank(v)+1
   * 若rank(u) < rank(v)，则使u指向v，v成为u的父亲
   * 若rank(u) > rank(v)，则使v指向u，u成为v的父亲

---

### 分治策略

* 把规模较大的问题分解为若干个规模较小的子问题，这些子问题相互独立且与原问题同类；(该子问题的规模减小到一定的程度就可以容易地解决）
* 依次求出这些子问题的解，然后把这些子问题的解组合起来得到原问题的解
* 由于子问题与原问题是同类的,故分治法可以很自然地应用递归



假设算法将规模为n的问题分解为a(a>=1)个规模为n/b(b>1)的子问题解决。分解子问题以及合并子问题的解耗费的时间为s(n)，则算法的时间复杂度可以递归表示为：
$$
T(n)=\left\{
\begin{aligned}
c\quad, n <= n_0 \\
aT(n/b)+s(n),n>=n_0
\end{aligned}
\right.
$$



**寻找中项和第k小元素**

给定已排好序的数组A[1,...,n]，中项是指其中间元素，若n为奇数，则中项为第(n+1)/2个元素；若n为偶数，取第n/2个元素作为元素。综上，中项为第[n/2]个最小元素。

* 若数组A中元素的个数小于一个阈值，那么采用直接排序的方法寻找第k小元素
* 否则将n个元素分为[n/5]组，每组6个元素，如果n不是5的倍数，则排除剩余的元素
* 对每组元素排序，并取出它们的中项，共有[n/5]个。然后，这[n/5]个中项的中项，我们记为mm
* 依据mm将数组A划分为三个子数组：$A_1=\{a|a<mm\}、A_2=\{a|a=mm\}、A_3=\{a|a>mm\}$
* 判断第k小元素可能在哪一个子数组中出现：如果在$A_2$中出现，则已经找到；否则，在$A_1$或$A_3$上进行递归



---

### 动态规划

基本步骤：

1. 找出最优解的性质，并刻画其结构特征
2. 递归地定义最优值
3. 以自底向上的方式计算出最优值
4. 根据计算最优值时得到的信息，构造最优解

#### 矩阵链相乘

**穷举法**

1. 找出所有可能的相乘结合方式
2. 计算每种相乘结合方式所需要的乘法次数
3. 求min

f(n)表示n个矩阵连乘所有可能的结合方式
$(M_1*M_2*M_3...M_k)*(M_{k+1}...M_n)$=f(k)*f(n-k)
$f(n)=\sum_{k=1}^{n-1}f(k)f(n-k)$=$\frac{4^n}{4\sqrt{\pi}n^{1.5}}$
$f(n)=\Omega(\frac{4^n}{n^{1.5}})$

**动态规划法**
$M_{i,j}=M_i*M_{i+1}...M_j$
$C[i,j]$：计算$M_{i,j}$所需的最小乘法次数。
$C[i,j]=min\{C[i,k-1]+C[k,j]+r_i*r_k*r_{j+1}\}$
$T(n)=\Theta(n^3)$

### 0-1背包问题

设V[i,j]表示从前i个物品$\{u_1,u_2,...,u_i\}$中取出一部分装入称重量为j的背包所能取得的最大价值。那么，当i=n，j=c时，V[n,C]就是问题的解
$$
V[i,j]=\left\{
\begin{aligned}
0, \quad if\quad i=0\quad or\quad j=0 \\
V[i-1,j], \quad if\quad j<w_i \\
max\{V[i-1,j],V[i-1,j-w_i]+v)i\}
\end{aligned}
\right.
$$

---

