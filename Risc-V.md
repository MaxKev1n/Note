# RV32I：RISC-V基础整数指令集

## RV32I 指令格式

**指令只有六种格式且均为32位长**

* R类型指令：用于寄存器-寄存器操作
* I型指令：用于短立即数和访存`load`操作
* S型指令：用于访存`store`操作
* B类型指令：用于条件跳转操作
* J型指令：用于无条件跳转
* U型指令：用于长立即数

<img src="https://cdn.jsdelivr.net/gh/MaxKev1n/Pictures//Risc_V/2.1.jpg" style="zoom:67%;" >

<img src="https://cdn.jsdelivr.net/gh/MaxKev1n/Pictures//Risc_V/2.2.jpg" style="zoom:67%;" >

**所有位全部是0是非法的RV32I指令，试图跳转到被清零的内存区域的错误跳转将会立即触发异常。类似地，所有位全部是1的指令也是非法指令**

---

## RV32I寄存器

**RV32I有31寄存器加上一个值恒为0的 x0寄存器**

构造32位常量：

1. 加载立即数到高位（`lui`）将20位常量加载到寄存器的高20位
2. 使用标准的立即指令来创建32位常量（`addi`）

**将auipc中的20位立即数与jalr参见下面中12位立即数的组合，我们可以将执行流转移到任何32位PC相对地址。而auipc加上普通加载或存储指令中的12位立即数偏移量，使我们可以访问任何 32 位PC 相对地址的数据。**

---

## RV32I 的 Load 和 Store

除了提供32位字（`lw`，`sw`）的加载和存储外，RV32支持加载有符号和无符号字节和半字(`lb`，`lbu`，`lh`，`lhu`)和存储字节和半字(`sb`，`sh`）。低位宽数据也是被扩展后再处理。

---

## RV32I条件分支

* `beq`：相等
* `bne`：不相等
* `bge`：不与等于（有符号）
* `blt`：小于（有符号）
* `bgeu`：大于等于（无符号）
* `bltu`：小于等于（无符号）

分支指令的寻址方式是12位的立即数乘以2，符号扩展它，然后将得到的值加到PC上作为分支的跳转地址。

```assembly
#不使用条件码实现大位宽数据的加法
add a0,a2,a4 # 加低 32 位: a0 = a2 + a4 
sltu a2,a0,a2 # 若 (a2+a4) < a2 那么 a2’ = 1, 否则 a2’ = 0 
add a5,a3,a5 # 加高 32 位: a5 = a3 + a5 
add a1,a2,a5 # 加上低 32 位的进位
```

**获取PC：当前的PC可以通过将`auipc`的U立即数字段设置为0来获得**

---

## RV32I无条件跳转

跳转并连链接指令（`jal`）具有双重功能：

* 若将下一条指令`PC+4`的地址保存到目标寄存器中，通常是返回地址寄存器`ra`，便可以用它来实现过程调用
* 如果使用零寄存器（`x0`）替换`ra`作为目标寄存器，则可以实现无条件跳转，因为`x0`不能更改

跳转和链接指令的寄存器版本（`jalr`）同样是多用途的。它可以调用地址是动态计算出来的函数，或者也可以实现调用返回（只需`ra`作为源寄存器，零寄存器（`x0`）作为目的寄存器。

*`jalr rd, offset(rs1)`：把pc设置为x[rs1]+sign-extend(offset)，把计算出的地址的最低有效位设为0，并将原 pc+4的值写入f[rd]。rd默认为x1。*

---

# RISC-V 汇编语言

## 函数调用规范

函数调用过程通常分为6个阶段：

1.  将参数存储到函数能够访问到的位置
2. 跳转到函数开始位置（使用RV32I的`jal`指令）
3. 获取函数需要的局部存储资源，按需保存寄存器
4. 执行函数中的指令
5. 将返回值存储到调用者能够访问到的位置，恢复寄存器，释放局部存储资源
6. 返回调用函数的位置（使用`ret`指令）

<img src="https://cdn.jsdelivr.net/gh/MaxKev1n/Pictures//Risc_V/3.2.jpg" style="zoom:67%;" >

```assembly
#函数开头
entry_label:
	addi sp, sp, -framesizes #调整栈指针（sp寄存器）分配栈帧
	sw ra, framsize-4(sp) #保存返回地址（ra寄存器）
	# 按需保存其他寄存器
	... #函数体
	#按需恢复其他寄存器
	lw ra, framesize-4(sp) #恢复返回地址
	addi sp, sp, framesize #释放栈帧空间
	ret #返回调用点
```

---

## 汇编器

常用的汇编指示符：

* `.text`进入代码段
* `.align 2`后续代码按$2^2$字节对齐
* `.globl main`声明全局符号“main”
* `.section .rodata`进入只读数据段
* `.balign 4`数据段按4字节对齐
* `.string "Hello, %s!\n"`创建空字符结尾的字符串
* `.string "world"`创建空字符结尾的字符串

---

## 静态链接和动态链接

动态链接时，编译器产生的代码和静态链接的代码很相似。其不同之处在于，跳转的目标不是实际的函数，而是一个只有三条指令的存根函数（stub function）。存根函数会从内存中的一个表中加载实际的函数的地址并跳转。不过，在第一次调用时，表中还没有实际的函数的地址，只有一个动态链接的过程的地址。当这个动态链接过程被调用时，动态链接器通过符号表找到实际要调用的函数，复制到内存中，更新记录实际的函数地址的表。

---

# 乘法和除法指令

RV32M具有有符号和无符号整数的除法指令：`div`和`divu`，它们将上放入目标寄存器。在少数情况下，程序员需要余数而不是商，因此RV32M提供`rem`和`remu`，它们在目标寄存器写入余数，而不是商。

<img src="E:\PIC\Risc_V\4.1.jpg" style="zoom:67%;" >

RISC-V中带有四个乘法指令：

* 要得到整数32位乘积（64位中的低32为）就用`mul`指令
* 要得到高32位，如果操作数都是有符号数，就用`mulh`指令
* 要得到高32位，如果操作数都是无符号数，就用`mulhu`指令
* 如果要得到高32位，如果一个有符号一个无符号，可以用`mulhsu`指令

---

# RV32F和RV32D：单精度和双精度浮点数

## 浮点寄存器

RV32F和RV32D使用32个独立的f寄存器而不是x寄存器。

如果处理器同时支持RV32F和RV32D扩展，则单精度数据仅使用f寄存器中的低32位。与RV32I中的`x0`不同，寄存器`f0`不是硬连线到常量0，二世和所有其他31个f寄存器一样，hi是一个可变寄存器。

<img src="https://cdn.jsdelivr.net/gh/MaxKev1n/Pictures//Risc_V/5.1.jpg" style="zoom:67%;" >

---

## 浮点加载，存储和算术指令

对于RV32F和RV32D，RISC-V有两条加载指令（`flw`，`fld`）和两条存储指令（`fsw`，`fsd`）。他们和`lw`和`sw`拥有相同的寻址模式和指令格式。添加到标准算术运算中的指令有：（`fadd.s`，`fadd.d`，`fsuib.s`，`fmul.s`，`fmul.d`，`fdiv.d`，`fdiv,d`），RV32F和RV32D还包括平方根（`fsqrt.s`，`fsqrt.d`）指令。它们也有最小值和最大值指令（`fmin.s`，`fmin.d`，`fmax.s`，`fmax.d`）。

RISC-V提供了指令用于先将两个操作数相乘然后将乘积加上（`fmadd.s`，`fmadd.d`）或减去（`fmsub.s`，`fmsub.d`）第三个操作数，最后再将结果写入目的寄存器。它还有在加上或减去第三个操作数之前对乘积取反的版本：`fnmadd.s`，`fnmadd.d`，`fnmsub.s`，`fnmsub.d`。

RV32F和RV32D没有提供浮点分支指令，而是提供了浮点比较指令，这些根据两个浮点的比较结果酱油给整数寄存器设置为1或0：`feq.s`，`feq.d`，`flt.s`，`flt.d`，`fle.s`，`fle.d`。

---

## 其他浮点指令

**符号注入指令**：它从第一个源操作数复制了除符号位之外的所有内容。符号位的取值取决于具体是什么指令：

1. 浮点符号注入（`fsgnj.s`，`fsgnj.d`）：结果的符号位是`rs2`的符号位
2. 浮点符号取反注入（`fsgnjn.s`，`fsgnjn.d`）：结果的符号位与`rs2`的符号位相反
3. 浮点符号异或注入（`fsgnjx.s`，`fsgnjx.d`）：结果符号位是`rs1`和`rs2`的符号位异或的结果

**`classify`分类指令（`fclass.s`，`fclass.d`）**：它们测试一个源操作数来看原操作数满足下列10个浮点数属性中的哪些属性，然后将测试结果的掩码写入目的整数寄存器的低10位。十位中仅有一为被设置为1，其余位都设置为0。

<img src="https://cdn.jsdelivr.net/gh/MaxKev1n/Pictures//Risc_V/df%20table.jpg" style="zoom:67%;" >

---

# 原子指令

RV32A有两种类型的原子操作

* 内存原子操作（AMO）
* 加载保留/条件存储（load reserved / store conditional）

<img src="https://cdn.jsdelivr.net/gh/MaxKev1n/Pictures//Risc_V/6.2.jpg" style="zoom:67%;" >

AMO指令对内存中的操作数执行一个原子操作，并将目标寄存器设置为操作前的内存值。原子表示内存读写之间的过程不会被打断，内存值也不会被其他处理器修改。

加载保留和条件存储保证了它们两条指令之间的操作的原子性。加载保留读取一个内存字，存入目标寄存器中，并留下这个字的保留记录。而*如果条件存储的目标地址上存在保留记录*，就把字存入这个地址。如果存入成功，它向目标寄存器中写入0；否则写入一个非0的错误代码。

---

# 压缩指令

基于以下的三点观察，架构师们成功地将指令压缩到了16位：

1. 对十个常用寄存器（`a0-a5`，`s0-s1`，`sp`以及`ra`）访问的频率远超过其他寄存器
2. 许多指令的写入目标是它的源操作数之一
3. 立即数往往很小，而且有些指令比较喜欢某些特定的立即数

<img src="https://cdn.jsdelivr.net/gh/MaxKev1n/Pictures//Risc_V/7.1.jpg" style="zoom:67%;" >

---

# 向量

<img src="https://cdn.jsdelivr.net/gh/MaxKev1n/Pictures//Risc_V/8.1.jpg" style="zoom:67%;" >

向量计算机从内存中收集数据并将它们放入长的，顺序的向量寄存器中。子啊这些向量寄存器上，流水线执行单元可以高效地执行运算。然后，向量架构将结果从向量寄存器中取出，并将其并分散地存回主存。向量寄存器的大小由实现决定。我们将会看到，*将向量的长度和每个时钟周期可以进行的最大操作数分离，是向量体系结构的关键所在*。

### 向量计算指令

---

# 64位指令

<img src="https://cdn.jsdelivr.net/gh/MaxKev1n/Pictures//Risc_V/9.1.jpg" style="zoom:67%;" >

<img src="https://cdn.jsdelivr.net/gh/MaxKev1n/Pictures//Risc_V/9.2.jpg" style="zoom:67%;" />

<img src="https://cdn.jsdelivr.net/gh/MaxKev1n/Pictures//Risc_V/9.3.jpg" style="zoom:67%;" >

<img src="https://cdn.jsdelivr.net/gh/MaxKev1n/Pictures//Risc_V/9.4.jpg" style="zoom:67%;" >

64位指令集只添加了32位指令对应的字(word)，双子(doubleword)和长整数(long)版本的指令，并将所有寄存器(包括PC)扩展为64位。

由于寄存器现在是64位宽，RV64I添加字版本的加法和减法指令：`addw`，`addiw`，`subw`。这些指令将计算结果截断为32位，结果符号扩展后再写入目标寄存器。

RV64I也包括字版本的移位指令(`sllw`，`slliw`，`srlw`，`srliw`，`sraw`，`sraiw`)，以获得32位移位结果而不是64位移位结果。要进行64位数据传输，RV64提供了加载和存储双字指令：`ld`，`sd`。RV64I也有一个无符号版本的加载字：`lwu`。

RV64添加了字版本的乘法、除法和取余指令：`mulw`，`divw`，`divuw`，`remw`，`remuw`。为了支持对单字及双字的同步操作，RV64A为其所有的11条指令都添加了双字版本。

RV64F和RV64D添加了整数双字转换指令，并称它们为长整数，以避免与双精度浮点数据混淆：`fcvt.l.s`，`fct.l.d`，`fcvt.lu.s`，`fcvt.lu.d`，`fcvt.s.l`，`fcvt.s.lu`，`fcvt.d.l`，`fcvt.d.lu`。由于整数x寄存器现在是64位宽，它们现在可以保存双精度浮点数据，因此RV64D增加了两个浮点指令：`fmv.x.w`和`fmv.w.x`。

RV64C放弃了压缩跳转并链接和整数和浮点加载和存储字指令。RV64C添加了字加减指令（`c.addw`,`c.addiw`,`c,subw`）以及加载和存储双字指令（`c.ld`，`c.sd`，`c.ldsp`，`c.sdsp`）。

---

# RV32/64特权架构

<img src="https://cdn.jsdelivr.net/gh/MaxKev1n/Pictures//Risc_V/10.2.jpg" style="zoom:67%;" >

## 简单嵌入式系统的机器模式

**机器模式（M-mode）**是RISC-V中*hart*可以执行的最高权限模式，是所有标准RISC-V处理器都必须实现的权限模式。

机器模式最重要的特性是拦截和处理异常的能力。

RISC-V将异常分为两种

1. 同步异常，这类异常再指令执行期间产生，如访问了无效的存储器地址或执行了具有无效操作码的指令时
2. 中断，它是与指令流异步的外部事件

M模式运行期间同步例外有5种：

1. 访问错误异常：当物理内存的地址不支持访问类型时发生
2. 断点异常：在执行`ebreak`指令，或者地址或数据与调试触发器匹配时发生
3. 环境调用异常：在执行`ecall`指令时发生
4. 非法指令异常：在译码阶段发现无效操作码时发生
5. 非对齐地址异常：在有效地址不能被访问大小整除时发生

有三种标准的中断源：

1. 软件中断：通过向内存映射寄存器中存数来触发，并通常用于由一个`hart`中断另一个`hart`
2. 时钟中断：当实数计数器`mtime`大于`hart`的时间比较器时除法
3. 外部中断：由平台级中断控制器触发

---

## 机器模式下的异常处理

八个控制状态寄存器（CSR）是机器模式下异常处理的必要部分：

* `mtvec`：保存发生异常时处理器需要跳转到的地址
* `mepc`：指向发生异常的指令
* `mcause`：指示发生异常的种类
* `mie`：指出处理器目前能处理和必须忽略的中断
* `mip`：列出目前正准备处理的中断
* `mtval`：保存了陷入（trap）的附加信息：地址例外中出错的地址、发生非法指令例外的指令本身，对于其他异常，它的值为0
* `mscratch`：暂时存放一个字大小的数据
* `mstatus`：保存全局中断使能，以及许多其他的状态

当一个hart发生异常时，硬件自动经历如下的状态转换：

* 异常指令的PC被保存在mepc中，PC被设置为mtvec。（对于同步异常，mepc指向导致异常的指令；对于中断，它指向中断处理后应该恢复执行的位置。）
* 根据异常来源设置mcause，并将mtval设置为出错的地址或者其它适用于特定异常的信息字。
* 把控制状态寄存器mstatus中的MIE位置零以禁用中断，并把先前的MIE值保留到MPIE中。
* 发生异常之前的权限模式保留在mstatus的MPP域中，再把权限模式更改为M。