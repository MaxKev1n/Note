# 拷贝、赋值与销毁<br>

------

## 拷贝构造函数

拷贝构造函数的第一个参数必须是一个**引用类型**

拷贝初始化不仅在我们用=定义变量时会发生，在下列情况下也会发生：<br>

- 将一个对象作为实参传递给一个非引用类型的形参
- 从一个返回类型为非引用类型的函数返回一个对象
- 用花括号列表初始化一个数组中的元素或一个聚合类中的成员。*例如，当我们初始化标准库容器或是调用其`insert`或`push`成员时，容器会对其元素进行拷贝初始化。与之相对的，用`emplace`成员创建的元素都进行直接初始化。*<br>

在函数调用过程中，具有非引用类型的参数要进行拷贝初始化。类似的，当一个函数具有非引用的返回类型时，返回值会被用来初始化调用方的结果。<br>

------

## 拷贝赋值运算符

### 重载赋值运算符

重载运算符本质上时函数，其名字由`operator`关键字后接表示要定义的运算符的符号组成。因此，赋值运算符就是一个名为`operator=`的函数。<br>

重载运算符的参数表示运算符的运算对象。某些运算符，包括赋值运算符，必须定义为成员函数。如果一个运算符是一个成员函数，其左侧运算对象就绑定到隐式的`this`参数。对于一个二元运算符，例如赋值运算符，其右侧运算对象作为显式参数传递。为了与内置类型的赋值保持一致，赋值运算符通常返回一个指向其左侧运算对象的引用。<br>

**赋值运算符通常应该返回一个指向其左侧运算对象的引用**

------

## 析构函数

析构函数释放对象使用的资源，并销毁对象的非`static`数据成员

析构函数是类的一个成员函数，名字由波浪号接类型构成。他没有返回值，也不接受参数：<br>

```c++
class Foo{
public:
	~Foo();   //析构函数
};
```

由于析构函数不接受参数，因此它不能被重载。对一个给定类，只会有唯一一个析构函数。<br>

在一个构造函数中，成员的初始化是在函数体执行之前完成的，且按照它们在类中出现的顺序进行初始化。在一个析构函数中，首先执行函数体，然后销毁成员。成员按照初始化顺序的逆序销毁。<br>

##### 什么时候会调用析构函数

无论何时一个对象被销毁，就会自动调用其析构函数：

* 变量在离开其作用域时被销毁
* 当一个对象被销毁时，其成员被销毁
* 容器（无论是标准库容器还是数组）被销毁时，其元素被销毁
* 对于动态分配的对象，当对指向它的指针被应用`delete`运算符时被销毁
* 对于临时对象，当创建它的完整表达式结束时被销毁

**Note：当指向一个对象的引用或指针离开作用域时，析构函数不会执行**

------

## 三/五法则

### 需要析构函数的类也需要拷贝和赋值操作<br>

当我们决定一个类是否要定义它自己版本的拷贝控制成员时，一个基本原则是首先确定这个类是否需要一个析构函数。通常，对析构函数的需求要比对拷贝构造函数或赋值运算符的需求更为明显。如果这个类需要一个析构函数，我们几乎可以肯定它也需要一个拷贝构造函数和一个拷贝赋值函数。

**Tip：如果一个类需要自定义析构函数，几乎可以肯定它也需要自定义拷贝赋值运算符和拷贝构造函数**

### 需要拷贝操作的类也需要赋值操作，反之亦然

如果一个类需要一个拷贝构造函数，几乎可以肯定它也需要一个拷贝赋值函数。反之亦然——如果一个类需要一个拷贝赋值运算符，几乎可以肯定它也需要一个拷贝构造函数。然而，无论是需要拷贝构造函数还是需要拷贝赋值运算符都不必然意味着需要也析构函数。

------

## 使用=default

我们可以通过拷贝控制成员定义为`=default`来显式地要求编译器生成合成的版本。当我们在类内用`=default`修饰成员的声明时，合成的函数将隐式地声明为内联的。如果我们不希望合成的成员是内联函数，应该只对成员的类外定义使用`=default`，就像对拷贝赋值运算符所做的那样。

------

## 阻止拷贝

### 定义删除的函数

在新标准下，我们可以通过将拷贝构造函数和拷贝赋值运算符定义为**删除的函数（deleted function）**来阻止拷贝。在函数的参数列表后面加上`=default`来指出我们希望将它定义为删除的：

```c++
struct NoCopy{
	NoCopy() = default;  //使用合成的默认构造函数
	NoCopy(const NoCopy&) = delete;  //阻止拷贝
	NoCopy &operator=(const NoCopy&) = delete;  //阻止赋值
	~NoCopy() = default;  //使用合成的析构函数
};
```

与`=default`不同，`=delete`必须出现在函数第一次声明的时候。与其的另一个不同之处是，我们可以对任何函数指定`=delete`。

### 析构函数不能是删除的成员

值得注意的是，我们不能删除析构函数。对于一个删除了析构函数的类型，编译器将不允许定义该类型的变量或创建该类的临时对象。而且，如果一个类有某个成员的类型删除了析构函数，我们也不能定义该类的变量或临时对象。

**Warning：对于析构函数已删除的类型，不能定义该类型的变量或者释放指向该类型动态分配对象的指针**

### 合成的拷贝控制成员可能是删除的

对某些类来说，编译器将这些合成的成员定义为删除的函数：

* 如果类的某个成员的析构函数是删除的或不可访问的（例如，是`private`的），则类的合成拷贝构造函数被定义为删除的
* 如果类的某个成员的拷贝构造函数是删除的或不可访问的，则类的合成拷贝构造函数被定义为删除的。如果类的某个成员的析构函数是删除的或不可访问的，则类合成的拷贝构造函数也被定义为删除的
* 如果类的某个成员的拷贝赋值运算符是删除的或不可访问的，或是有一个`const`的或引用成员，则类的合成拷贝赋值运算符被定义为删除的
* 如果类的某个成员的析构函数是删除的或不可访问的，或是类有一个引用成员，它没有类内初始化器，或是类有一个`const`成员，它美哦与类内初始化器且类型未显式定义默认构造函数，则该类的默认构造函数被定义为删除的

### private拷贝控制

通过声明（但不定义）`private`的拷贝构造函数，我们可以预先阻止任何拷贝该类型对象的企图：试图拷贝对象的用户代码将在编译阶段被标记为错误；成员函数或友元函数中的拷贝操作将会导致链接时错误。

------

# 拷贝控制和资源管理

**对于一个赋值运算符来说，正确工作方法时非常重要的，即使是将一个对象赋予它自身也要能正确工作。一个好的方法是在销毁左侧运算对象资源之前拷贝右侧运算对象**

有时我们希望直接管理资源。在这种情况下，使用**引用计数（reference count）**就很有用了。为了说明引用计数如何工作，我们将重新定义类，令其行为像指针一样，但我们不使用`shared_ptr`，而是设计自己的引用计数。

**引用计数**

引用计数的工作方式如下：

* 除了初始化对象外，每个构造函数（拷贝构造函数除外）还要创建一个引用计数，用来记录有多少对象与正在创建的对象共享状态。当我们创建一个对象时，只有一个对象共享状态，因此将计数器初始化为1
* 拷贝构造函数不分配新的计数器，二十拷贝给定对象的数据成员，包括计数器。拷贝构造函数递增共享的计数器，指出给定对象的状态又被一个新用户所共享
* 析构函数递减计数器，指出共享状态的用户少了一个。如果计数器变为0，则析构函数释放状态
* 拷贝赋值运算符地之能右侧运算对象的计数器，递减左侧运算对象的计数器。如果左侧运算对象的计数器变为0，意味着它的共享状态没有用户了，拷贝赋值运算符就必须销毁状态

------

## 交换操作

定义swap的类通常用swap来定义它们的赋值运算符。这些运算符使用了一种名为**拷贝并交换（copy and swap）**的技术。这种技术将左侧运算对象与右侧运算对象的一个副本进行交换。

```c++
HasPtr HasPtr::operator=(HasPtr rhs){
	swap(*this, rhs);  //rhs现在指向本对象曾经使用的内存
	return *this;      //rhs被销毁，从而delete了rhs中的指针
}
```

------

# 对象移动

## 右值移动

为了支持移动操作，新标准引入了一种新的引用类型——**右值引用（rvalue reference）**。所谓右值引用就是必须绑定到右值的引用。我们通过`&&`而不是`&`来获得右值引用。如我们将要看到的，右值引用有一个重要的性质——只要能绑定到一个将要销毁的对象。因此，我们可以自由地建议给右值引用的资源“移动”到另一个对象中。

由于右值引用只能绑定到临时对象，我们得知

* 所引用的对象将要被销毁
* 该对象没有其他用户

**Note：变量是左值，因此我们不能嫁给你一个右值引用直接绑定到一个变量上。即使这个变量是右值引用类型也不行**

### 标准库move函数

虽然蹦年将一个右值引用直接绑定到一个左值上，但我们可以显式地将一个左值转换为对应的右值引用类型。我们还可以通过调用一个名为**`move`**的新标准库函数来获得绑定到左值上的右值引用，此函数定义在头文件`utility`中。

```c++
int &&rr3 = std::move(rrl);
```

`move`调用告诉编译器：我们有一个左值，但我们希望像一个右值一样处理它。我们必须认识到，调用`move`就意味着承诺：除了对rrl赋值或销毁它外，我们将不再使用它。在调用`move`后，我们不能对移后源对象的值做任何假设。

**Warning：使用`move`的代码应该使用`std::move`而不是`move`。这样做可以避免潜在的名字冲突**

------

## 移动构造函数和移动赋值运算符

类似拷贝构造函数，移动构造函数的第一个参数是该类类型的一个引用。不同于拷贝构造函数的是，这个引用参数在移动构造函数中是一个右值引用。与拷贝构造函数一样，任何额外的参数都必须有默认实参。

**Note：不抛出异常的移动构造函数和移动赋值运算符必须标记为`noexcept`**

**移后源对象必须可析构**，从一个对象移动数据并不会销毁此对象，但有时在移动操作完成后，源对象会被销毁、因此，当我们编写一个移动操作时，必须确保移后源对象进入一个可析构的状态。

除了将移后源对象置为析构安全的状态之外，移动操作还必须保证对象仍然是有效的。一般来说，对象有效就是指可以安全地为其赋予新值或者可以安全地使用而不依赖其当前值。另一方面，移动操作对移后源对象中留下地值没有任何要求。因此，我们的程序不应该依赖与移后源对象中的数据。

只有当一个类没有定义任何自己版本的拷贝控制成员，且类的每个非`static`数据成员都可以移动时，编译器才会为它合成移动构造函数或者移动赋值运算符。

与拷贝操作不同，移动操作永远不会隐式定义为删除的函数，但是，如果我们显式地要求编译器生成`=default`地移动操作，且编译器不能移动所有成员，则编译器会将移动操作定义为删除的函数。

**什么时候将合成的移动操作定义为删除的函数遵循与定义删除地合成拷贝操作类似的原则：**

* 与拷贝构造函数不同，移动构造函数被定义为删除的函数的条件是：有类成员定义了自己的拷贝构造函数且未定义移动构造函数，或者是有类成员未定义自己的拷贝构造函数且编译器不能为其合成移动构造函数。移动赋值运算符地情况类似。
* 如果有类成员的移动构造函数或移动赋值运算符被定义为删除的或是不可访问的，则类的移动构造函数或移动赋值运算符被定义为删除的。
* 类似拷贝构造函数，如果类的析构函数被定义为删除的或不可访问的，则类的移动构造函数被定义为删除的。
* 类似拷贝赋值运算符，如果有类成员是`const`的或是引用，则类的移动赋值运算符被定义为删除的。

### 移动迭代器

新标准库中定义了一种**移动迭代器（move iterator）**适配器。一个 移动迭代器通过改变给定迭代器的解引用运算符的行为来适配此迭代器。一般来说，一个迭代器的解引用运算符返回一个指向元素的左值。与其他迭代器不同，移动迭代器为解引用运算符生成一个右值引用。我们通过调用标准库的`make_move_iterator`函数将一个普通迭代器转换为一个移动迭代器。此函数接受一个迭代器参数，返回一个移动迭代器。

`uninitialized_copy`对输入序列中的每个元素调用`construct`来将元素“拷贝”到目的位置。此算法使用迭代器的解引用运算符从输入序列中提取元素。由于我们传递给它的是移动迭代器，因此解引用运算符生成的是一个右值引用，这意味着`construct`将使用移动构造函数来构造元素。

**Note：区分移动和拷贝的重载函数通常有一个版本接受一个`const T&`，而另一个版本接受一个`T&&`**



