# 重载运算与类型转换

## 基本概念

重载的运算符是具有特殊名字的函数：它们的名字由关键字`operator`和其后要定义的运算符号共同组成。和其他函数一样，重载的运算符也包含返回类型，参数列表以及函数体。

重载运算符函数的参数数量与该运算符作用的运算对象数量一样多，一元运算符有一个参数，二元运算符有两个。对于二元运算符来说，左侧运算对象传递给第一个参数，而右侧运算对象传递给第二个参数。除了重载的函数调用运算符`operator()`之外，其他重载运算符不能含有默认实参。

如果一个运算符函数是成员函数，则它的第一个（左侧）运算对象绑定到隐式的`this`指针上，因此，成员运算符函数（显式）参数数量比运算符运算对象总数少一个。

对于一个运算符函数来说，它或者是类的成员，或者是类的成员，或者至少含有一个类类型的参数。

对于一个重载的运算符来说，其优先级和结合律与对应的内置运算符保持一致。不考虑运算对象的话。

### 直接调用一个重载的运算符函数

```c++
data1 + data2;           //普通的表达式
operator+(data1, data2); //等价的函数调用
data1 += data2;          //基于“调用”的表达式
data1.operator+=(data2); //对成员运算符函数的等价调用
```

### 某些运算符不应该被重载

因为使用重载的运算符本质上是一次函数调用，所以这些关于运算对象求值顺序的规则无法应用到重载的运算符。特别是，逻辑与运算符、逻辑或运算符和逗号运算符的运算对象求值顺序规则都无法保留下来。除此之外，`&&`和`||`运算符的重载版本也无法保留内置运算符的短路求值属性，两个运算对象总是会被求值。

------

**下面的准则有助于我们在将运算符定义为成员函数还是普通的非成员函数做出抉择：**

* 赋值（`=`）、下标（`[]`）、调用（`()`）和成员访问箭头(`->`)运算符必须是成员
* 复合赋值运算符一般来说应该是成员，但并非是必须，这一点和赋值运算符略有不同
* 改变对象状态的运算符或者与给定类型密切相关的运算符，如递增、递减和解引用运算符，通常应该是成员
* 具有对称性的运算符可能转换成任意一端的运算对象，例如算术、相等性、关系和位运算符等等，因此它们通常应该是普通的非成员函数

如果我们想提供含有类对象的混合类型表达式，则运算符必须定义成非成员函数。当我们把运算符定义成成员函数时，它的左侧运算对象必须是运算符所属的一个对象。

------

## 输入输出运算符

### 重载输出运算符<<

通常情况下，输出运算符的第一个形参是要给非常量`ostream`对象的引用。第二个形参一般来说时一个常量的引用，这常量是我们想要打印的类类型。

```c++
ostream &operator<<(ostream &os, const Sales_data &item){
	os<<item.isbn()<<" "<<item.unites_sold<<" "
	  <<item.revenue<<" "<<item.avg_price();
	return os;
}
```

与`iostream`标准库兼容的输入输出运算符必须是普通的非成员函数，而不能是类的成员函数。否则，它们的左侧运算对象将是我们的类的一个对象。

如果我们希望为类自定义IO运算符，则必须将其定义为非成员函数。当然，IO运算符通常需要读写类的非公有数据成员，所以IO运算符一般被声明为友元。

### 重载输入运算符>>

通常情况下，输入运算符的第一个形参时运算符将要读取的流的引用，第二个形参时将要读入到的（非常量）对象的引用。

## 算术和关系运算符

通常情况下，我们把算术和关系运算符定义成非成员函数以允许对左侧或右侧的运算对象进行转换。因为这些运算符一般不需要该改变运算对象的状态，所以形参都是常量的引用。

### 下标运算符

**下标运算符必须是成员函数**

为了与下标的原始定义兼容，下标运算符通常以所访问元素的引用作为返回值，这样做的好处是下标可以出现在赋值运算符的任意一端。进一步，我们最好用是定义下标运算符的常量版本和非常量版本，当作用于一个常量对象时，下标运算符返回常量引用以确保我们不会给返回的对象赋值。

## 递增和递减运算符

区分前置和后置，后置版本接受一个额外的（不被使用）`int`类型的形参。当我们使用后置运算符时，编译器为这个形参提供一个值为0的实参。尽管从语法上来说后置函数可以使用这个额外的形参，但是在实际过程中通常不会这么做。这个形参的唯一作用就是区分前置版本和后置版本的函数，而不是真的要在实现后置版本时参与运算。

可以显式地调用一个重载的运算符，其效果与在表达式中以运算符号的形式使用它完全一样。如果我们想通过函数调用的方式调用后置版本，则必须为它的整型参数传递一个值：

```c++
StrBlobPtr p(a1);
p.operator++(0);
p.operator++();
```

## 成员访问运算符

**箭头运算符必须是类的成员。解引用运算符通常也是类的成员，尽管并非必须如此**

和大多数其他运算符一样，我们能令`operator*`完成我们指定的操作，但它永远不能丢掉成员访问这个最基本的含义。当我们宠爱箭头时，可以改变的是箭头从哪个对象当中获取成员，而箭头获取成员这一事实则永远不变。

**Note：重载的箭头运算符必须返回类的指针或者自定义了箭头运算符的某个类的对象**

------

## 函数调用运算符

如果类重载了函数调用运算符，则我们可以想使用函数一样使用该类的对象

```c++
struct absInt{
	int operator()(int val) const{
		return val < 0 ? -val : val;
	}
};
int i = -42;
absInt absObj;
int ui = absObj(i);
```

**Note：函数调用运算符必须是成员函数。一个类可以定义多个不同版本的调用运算符，相互之间应该在参数数量或类型上有所区别**

如果类定义了调用运算符，则该类的对象称作**函数对象（function object）**。

### 标准库定义的函数对象

标准库定义了一组表示算术运算符、关系运算符和逻辑运算符的类，每个类分别定义了一个执行命名操作的调用运算符。这些类都被定义成模板的形式，我们可以为其指定具体的应用类型，这里的类型即调用运算符的形参类型。

```c++
plus<int> intAdd;             //可执行int加法的函数对
negate<int> intNegate;        //可对int值取反的函数对象
//使用intAdd::operator(int, int)求10和20的和
int sum = intAdd(10, 20);     //等价于sum = 30
sum = intNegate(intAdd(10, 20));  //等价于sun = 30
//使用intNegate::operator(int)生成-10
//然后将-10作为intAdd::operator(int, int)的第二个参数
sum = intAdd(10, intNegate(10));
```

#### 在算法中使用标准库函数对象

表示运算符的函数对象类常用来替换算法中的默认运算符。如我们所知，在默认情况下排序算法使用`operator<`将序列按照升序排列。如果要执行降序排列的话，我们可以传入一个`greater`类型的对象。该类将产生一个调用运算符并负责执行待排序类型的大小运算。

```c++
sort(svec.begin(), svec.end(). greater<string>());
```

需要特别注意的是，标准库规定其函数对象对于指针同样使用。

### 可调用对象与function

对于几个可调用对象共享同一种调用形式的情况，有时我们会希望把它们看成具有相同的类型。我们希望使用这些可调用对象构建一个简单的桌面计算机。为了实现这一目的，需要定义一个**函数表（function table）**用于存储指向这些可调用对象的“指针”。当程序需要执行某个特定的操作时，从表中查找该调用的函数。

我们可以使用一个名为**`function`**的新标准库类型解决上述问题，`function`定义在`functional`头文件中。`function`是一个模板，和我们使用过的其他模板一样，当创建一个具体的`function`类型时我们必须提供额外的信息。

#### 重载的函数与function

我们不能（直接）将重载函数的名字存入`function`类型的对象中，会出现二义性问题。解决上述二义性问题的一条途径是存储函数指针而非函数的名字

```c++
int (*fp)(int, int) = add;
binops.insert({"+", fp});
```

同样，我们也可以使用`lambda`来消除二义性。

```c++
binops.insert({"+", [](int a, int b){return add(a, b);}});
```

------

## 重载、类型转换与运算符

### 类型转换运算符

**类型转换运算符（conversion operator）**是类的一种特殊成员函数，它负责将要给类类型的值转换成其他类型。类型转换函数的一般形式如下形式：

```c++
operator type() const;
```

其中*type*表示某种类型。类型转换运算符可以面向任意类型（除了`void`之外）进行定义。只要该类型能作为函数的返回类型。因此，我们不允许转换成数组或者函数类型，但允许转换成指针或者引用类型。类型转换运算符既没有显式的返回类型，也没有形参，而且必须定义成类的成员函数。

#### 显式的类型转换运算符

C++11新标准引入了**显式的类型转换运算符（explicit conversion operator）**。和显式的构造函数一样，编译器（通常）也不会讲要给显式的类型转换运算符用于隐式类型转换。当类型转换运算符是显式的时，我们也能执行类型转换，不过必须通过显式的强制类型转换才可以。

该规定存在一个例外，即如果表达式被用作条件，则编译器会将显式的类型转换自动应用于它。换句话说，当表达式出现在下列位置时，显式的类型转换将被隐式地执行：

* `if`、`while`及`do`语句的条件部分
* `for`语句头的条件表达式
* 逻辑非运算符(`!`)、逻辑或运算符(`||`)、逻辑与运算符(`&&`)的运算对象
* 条件运算符(`? :`)的条件表达式





