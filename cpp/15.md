# 面向对象程序设计

## OOP

通过**继承（inheritance）**联系在一起的类构成一种层次关系。通常在层次关系的根部有一个**基类（base class）**。其他类则直接或间接地从基类继承而来，这些继承得到的类称为**派生类（derived class）**。基类负责定义在层次关系中所有类共同拥有的成员，而每个派生类定义各自持有的成员。

某些函数，基类希望它的派生类各自定义适合自身的版本，此时基类就将这些函数声明成**虚函数（virtual function）**。

派生类必须通过使用**类派生列表（class derivation list）**明确指出它是从哪个（哪些）基类继承而来的。类派生列表的形式是：首先是一个冒号，后面紧跟以逗号分隔的基类列表，其中每个基类钱买你可以有访问说明符。

### 成员函数与继承

基类通过在其成员函数的声明语句之前加上关键字`virtual`使得该函数执行动态绑定。任何构造函数之外的非静态函数都可以是虚函数。关键字`virtual`只能出现在类内部的声明语句之前而不能用于类外部的函数定义。如果基类把一个函数声明成虚函数，则该函数在派生类中隐式地也是虚函数。成员函数如果没有被声明为虚函数，则其解析过程发生在编译时而不是运行时。

**基类希望它的派生类有权访问该成员，同时禁止其他用户访问。我们用`protected`访问运算符说明这样的成员**

------

### 定义派生类

派生类必须通过使用**类派生列表（class derivation list）**明确指出它从哪个（哪些）基类继承而来的。类派生列表的形式是：首先是一个冒号，后面紧跟以逗号分隔的基类列表，其中每个基类前面可以有以下三种访问说明符中的一个：`public`、`protected`、`private`。

### 继承与静态成员

如果基类定义了一个静态成员，则在整个继承体系中只有在该成员的唯一定义。不论从基类中派生出来多少个派生类，对于每个静态成员来说都只存在唯一的实例。

### 派生类的声明

派生类的声明与其它类差别不大，声明中包含类名但是不包含它的派生列表

------

**如果我们想将某个类用作基类，则该类必须已经定义而非仅仅声明**

有时我们会定义这样一种类，我们不希望其他类继承它，或者不想考率它是否适合作为一个基类，为了实现这一目的，C++11新标准提供了一种防止继承发生的方法，即在类名后跟一个关键字`final`。

我们可以将基类的指针或引用绑定到派生类对象上，可以将基类的指针或引用绑定到派生类对象中有一层极为重要的函数：当使用基类的引用（或指针）时，实际上我么你并不清楚该引用（或指针）所绑定的对象的真实类型，该对象可能是基类的对象，也可能是派生类的对象。

因为类的成员接受引用作为参数，所以派生类向基类的转换允许我么你给基类的拷贝/移动操作传递一个派生类的对象。这些操作不是虚函数。当我们给基类的构造函数传递一个派生类对象时，实际运行的构造函数是基类中定义的那个，显然该构造函数只能处理基类的自己的成员。类似的，如果我们将一个派生类对象赋值给一个基类对象，则实际运行的赋值运算符也是基类中定义的那个，该运算符同样只能处理基类自己的成员。

------

## 虚函数

**必须要搞清楚的一点是，动态绑定只有当我们通过指针或引用调用虚函数时才会发生**

一个派生类的函数如果覆盖了某个继承而来的虚函数，则它的形参类型必须与被它覆盖的基类函数完全一致。同样，派生类中虚函数的返回类型也必须与基类函数相匹配。该规则存在一个例外，当类的虚函数返回类型是类本身的指针或引用时。

派生类如果定义了一个函数与基类中虚函数的名字相同但是形参列表不同，这仍然是合法的行为。编译器将认为新定义的这个函数与基类中原有的函数是相互独立的。这时，派生类的函数并没有覆盖掉基类的版本。如果我们使用`override`来标记了某个函数，但该函数并没有覆盖已存在的虚函数，此时编译器将报错。

如果我们通过基类的引用或指针调用函数，则使用基类中定义的默认实参，即使实际运行的是派生类中的是派生类中的函数版本也是如此。此时，传入派生类函数的将是基类函数定义的默认实参。如果派生类函数依赖不同的实参，则程序结果将与我们的预期不符。

在某些情况下，我们希望对虚函数的调用不要进行动态绑定，而是强迫其执行虚函数的某个特定版本。使用域运算符可以实现这一目的。

```c++
double undiscounted = baseP->Quote::net_price(42);
```

**Note：通常情况下，只有成员函数（或友元）中的代码才需要使用作用域运算符来回避虚函数的机制**

什么时候我们需要回避虚函数的默认机制呢？通常是当一个派生类的虚函数调用它覆盖的基类的虚函数版本时。在此情况下，基类的版本通常完成继承层次中所有类型都要做的共同任务，而派生类中定义的版本需要执行一些与派生类本身密切相关的操作。

**Warning：如果一个派生类虚函数需要调用它的基类版本，但是没有使用作用域运算符，则在运行时该调用将被解析为对派生类版本自身的调用，从而导致无限递归。**

------

## 抽象基类

### 纯虚函数

**纯虚函数（pure virtual）**无须定义，我们通过在函数体的位置（即在声明语句的分号之前）书写`=0`就可以将一个虚函数说明为纯虚函数。其中，`=0`只能出现在类内部的虚函数声明语句处。值得注意的是，我们也可以为纯虚函数提供定义，不过函数体必须定义在类的外部。也就是说，我们不能在类的内部为一个`=0`的函数提供函数体。

含有（或者未经覆盖直接继承）的类是**抽象基类（abstract base class）**。抽象基类负责定义接口，而后续的其他类可以覆盖该接口。我们不能（直接）创建一个抽象基类的对象。

------

## 访问控制与继承

一个类使用`protected`关键字来声明那些希望它与派生类分享但是不想被其他公共访问使用的成员。

某个类对其继承而来的成员的访问权限受到两个因素影响：一是在基类中该成员的访问说明符，二是在派生类的派生列表中的访问说明符。派生访问说明符对于派生类的成员（及友元）能否访问其直接基类的成员没什么影响。对基类成员的访问权限只与基类中的访问说明符有关。

派生说明符的目的是控制派生类用户（包括派生类的派生类在内）对于基类成员的访问权限。

派生类向基类的转换是否可访问由使用该转换的代码决定，同时派生类的派生说明符也会有影响。

#### 友元与继承

就像友元关系不能传递一样，友元关系同样也不能继承。基类的友元在访问派生类成员时不具有特殊性，类似的，派生类的友元也不饿能随意访问基类的成员。

通过在类的内部使用`using`声明语句，我们可以将该类的直接或间接基类中的任何可访问成员标记出来。`using`声明语句中名字的访问权限由该`using`声明语句之前的访问说明符来决定。也就是说，如果一条`using`声明语句出现在类的`private`部分，则该名字只能被类的成员和友元访问；如果`using`声明语句位于`public`部分，则类的所有用户都能访问它；如果`using`声明语句位于`protected`部分，则该名字对于成员、友元和派生类是可以访问的。

**默认情况下，使用`class`关键字定义的派生类是私有继承的；而使用`struct`关键字定义的派生类是公有继承的**

------

## 继承中的类作用域

每个类定义自己的作用域，在这个作用域内我们定义类的成员。当存在继承关系时，派生类的作用域嵌套在其基类的作用于之内。如果一个名字在派生类的作用域内无法正确解析，则编译器将继续在外层的基类作用域中寻找改名字的定义。

和其他作用域一样，如果派生类（即内层作用域）的成员与基类（即外层作用域）的某个成员同名，则派生类将在其作用域内隐藏该基类成员。即使派生类成员和基类成员的形参列表不一致，基类成员也仍然会被隐藏掉。

------

## 构造函数和拷贝控制

#### 虚析构函数

和其他虚函数一样，析构函数的虚属性也会被继承。因此，无论派生类使用合成的析构函数还是定义自己的析构函数，都将是虚析构函数。只要基类的析构函数是虚函数，就能确保当我们`delete`基类指针时将运行正确的析构函数版本。

**Warning：如果基类的析构函数不是虚函数，则`delete`一个只想派生类对象的基类指针将产生未定义的行为**

某些定义基类的方式也可能导致有的派生类成员成为被删除的函数：

* 如果基类中的默认构造函数、拷贝构造函数、拷贝赋值函数或析构函数是被删除的函数或者不可访问，则派生类中对应的成员将是被删除的，原因是编译器不能使用基类成员来执行派生类对象基类部分的构造、赋值或销毁操作
* 如果在基类中有一个不可访问或删除掉的析构函数，则派生类中合成的默认和拷贝构造函数将是被删除的，因为编译器无法销毁派生类对象的基类部分。
* 和过去一样，编译器将不会合成一个删除掉的移动操作。当我们使用`=default`请求一个移动操作时，如果基类中的对应操作是删除的或不可访问的，那么派生类中该函数将是被删除的，原因是派生类对象的基类部分不可移动。同样，如果基类的析构函数是删除的或不可访问的，则派生类的移动构造函数也将是被删除的

因为基类缺少移动操作会阻止派生类拥有自己的合成移动操作，所以当我们确实需要执行移动操作时应该首先在基类中进行定义。

和构造函数及赋值运算符不同的是，析构函数只负责销毁派生类自己分配的资源，如前所述，对象的成员是被隐式销毁的，类似的，派生类对象的基类部分也是自动销毁的。

**当派生类定义了拷贝或移动操作时，该操作负责拷贝或移动包括基类部分成员在内的整个对象**

在析构函数体执行完成后，对象的成员会被隐式销毁。类似的，对象的基类部分也是隐式销毁的。因此，和构造函数及赋值运算符不同的是，派生类析构函数只负责销毁由派生类自己分配的资源。

对象的销毁的顺序正好与其创建的顺序相反：派生类析构函数首先执行，然或是基类的析构函数，以此类推，沿着继承体系的反方向直至最后。

和普通成员的`using`声明不一样，一个构造函数的`using`声明不会改变该构造函数的访问级别。而且，一个`using`声明语句不能指定`explicit`或`constexptr`。如果基类的构造函数是`explicit`或者`constexptr`，则继承的构造函数也拥有相同的属性。当一个基类构造函数含有默认实参时，这些实参并不会被继承。相反，派生类将获得多个继承的构造函数，其中每个构造函数分别省略掉一个含有默认实参的形参。

如果积累含有几个构造函数，则除了两个例外情况，大多数时候派生类会继承所有这些构造函数。第一个例外是派生类可以继承一部分构造函数，而为其他构造函数定义自己的版本。如果派生类定义的构造函数与基类的构造函数具有相同的参数列表，则该构造函数将不会被继承。定义在派生类中的构造函数将替换继承而来的构造函数。

第二个例外是默认、拷贝和移动函数不会被继承，这些构造函数按照正常规则被合成。继承的构造函数不会被作为用户定义的构造函数来使用，因此，如果一个类只含有继承的构造函数，则它也将拥有一个合成的默认构造函数。

------

## 容器与继承

当我们希望在容器中存放具有继承关系的对象时，我们实际上存放的通常是基类的指针（更好的选择是智能指针）。和往常一样，这些指针所指对象的动态类型可能是基类类型，也可能是派生类类型。



