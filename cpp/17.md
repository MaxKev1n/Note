# 标准库特殊设施

## tuple类型

**`tuple`**是类似`pair`的模板。每个`pair`的成员类型都不相同，但每个`pair`都恰好有两个成员。不同`tuple`类型的成员类型也不相同，但一个`tuple`可以有任意数量的成员。每个确定的`tuple`类型的成员数量是固定的，但一个`tuple`类型的成员数目可以与领域给`tuple`类型不同。

当我们定义一个`tuple`时，需要指出每个成员的类型。当我们创建要给`tuple`对象时，可以使用`tuple`的默认构造函数，它会对每个成员进行值初始化，也可以为每个成员提供一个初始值。`tuple`的这个构造函数时`explict`的，因此我们必须使用直接初始化语法：

```c++
tuple<size_t, size_t, size_t> threeD = {1, 2, 3};    //错误
tuple<size_t, size_t, size_t> threeD{1, 2, 3};       //正确
```

要访问一个`tuple`的成员，就要使用一个名为**`get`**的标准库函数模板。为了使用`get`，我们必须指定一个显式模板实参，它指出我们想要访问第几个成员。我们传递给`get`一个`tuple`对象，它返回指定成员的引用。

如果不知道一个`tuple`准确的类型细节信息，可以用两个辅助类模板来查询`tuple`成员的数量和类型：

```c++
typedef decltype(item) trans;
size_t sz = tuple_size<trans>::value;
tuple_element<1, trans>::type cnt = get<1>(item);
```

只有两个`tuple`具有相同数量的成员时，我们才可以比较它们。而且，为了使用`tuple`的相等或不等运算符，对每对成员使用`==`运算符必须都是合法的；为了使用关系运算符，对每对成员使用<必须都是合法的。

------

## bitset类型

标准库还定义了**`bitset`**类，使得位运算的使用更为容易，并且能够处理超过最长整型类型大小的位集合。`bitset`类定义在头文件`bitset`中。

`bitset`类是一个类模板，它类似`array`类，具有固定的大小。当我们定义一个`bitset`时，需要声明它包含多少个二进制位：

```c++
bitset<32> bitvec(1U);
```

大小必须是常量表达式。`bitvec`包含编号从`0`到`31`的32个二进制位。编号从`0`开始的二进制位被称为**低位（low-order）**，编号到`31`结束的二进制位被称为**高位（high-order）**。

当我们使用一个整型值来初始化`bitset`时，此值将被转换为`unsigned long long`类型并被当作位模式来处理。`bitset`中的二进制位将是此模式的一个副本。如果`bitset`的大小大于一个`unsigned long long`中的二进制位数，则剩余的高位被置为0。如果`bitset`的大小小于一个`unsigned long long`中的二进制位数，则只使用给定值中的低位，超出`bitset`大小的高位被丢弃。

我们可以从一个`string`或一个字符数组指针来初始化`bitset`。两种情况下，字符都直接表示位模式。与往常一样，当我们使用字符串表示数时，字符串中下标最小的字符对应高位，反之亦然。如果`string`包含的字符数比`bitset`少，则`bitset`的高位被置为0.

我们不必使用整个`string`来作为`bitset`的初始值，可以只用要给子串作为初始值：

```c++
string str("1111111000000011001101");
bitset<32> bitvec5(str, 5, 4);
bitset<32> bitvec6(str, str.size() - 4);
```

------

## 正则表达式

**正则表达式（regular expression）**是一种描述字符序列的方法，是一种极其强大的计算工具。C++正则表达式库（RE库），是新标准库的一部分，定义在头文件`regex`中。

函数**`regex_match`**和**`regex_search`**确定一个给定字符序列与一个给定`regex`是否匹配。如果整个输入序列与表达式匹配，则`regex_match`函数返回`true`；如果输入序列中一个子串与表达式匹配，则`regex_search`函数返回`true`。

如果我们编写的正则表达式存在错误，则在运行时标准库会抛出一个类型为**`regex_error`**的异常。

我们可以使用**`sregex_iterator`**来获得所有匹配。`regex`迭代器是一种迭代器适配器，被绑定到一个输入序列和一个`regex`对象中。

------

## 随机数

定义在头文件`random`中的随机数库通过一组协作的类来解决这些问题：**随机数引擎类（random-number engines）**和**随机数分布类（random-number distribution）**。一个引擎类可以生成`unsigned`随机数序列，一个分布类使用一个引擎类生成指定类型的、在给定范围内的、服从特定概率分布的随机数。

随机数隐情史函数对象类，它们定义了一个调用运算符，该运算符不接受参数并返回一个随机`unsigned`整数。我们可以通过调用要给随机数引擎对象来生成原始随机数：

```c++
default_random_engine e;
for(size_t i = 0;i < 10;i++)
	cout<<e()<<" ";
```

为了得到在一个指定范围内的数，我们使用一个分布类型的对象：

```c++
uniform_int_distrubution<unsigned> u(0,9);
default_random_engine e;
for(size_t i = 0;i < 10;i++)
	cout<<u(e)<<" ";
```

**Warning：一个给定的随机数发生器一直会生成相同的随即数序列。一个函数如果定义了局部的随机数发生器，应该将其（包括引擎和分布对象）定义为`static`的。否则，每次调用函数都会生成相同的序列**

随机数发生器会生成相同的随机数序列这一特性在调试中很有用。但是，一旦我们的程序调式完毕，我们通常希望每次运行程序都会生成不同的随即结果，可以通过提供一个**种子（seed）**来达到这一目的。种子就是一个数值，引擎可以利用它从序列中一个新位置重新开始生成随机数。为引擎设置种子有两种方法：在创建引擎对象时提供种子，或者调用引擎的`seed`成员。

选择一个好的种子，与生成好的随机数所涉及的其他大多数事情相同，时极其困难的。可能最常用的方法是调用系统函数`time`。这个函数定义在头文件`ctime`中，它返回从一个特定时刻到当前经过了多少秒。函数`time`接受单个指针参数，它指向用于写入时间的数据结构。如果此指针为空，则函数简单地返回时间：

```c++
default_random_engine el(time(0));
```

由于`time`返回以秒计的时间，因此这种方式只适用于生成种子的间隔为秒级或更长的应用。

#### 其他随机数分布

分布类型都是模板，具有单一的模板类型参数，表示分布生成的随机数的类型，对此有一个例外。这些分布要么生成浮点类型，要么生成整数类型。

每个分布模板都有一个默认模板实参。生成浮点值的分布类型默认生成`double`值，而生成整型值的分布默认生成`int`值。由于分布类型只有一个模板参数，因此当我们希望使用默认随机数类型时要记得在模板名之后使用空间括号：

```c++
uniform_real_distribution<> u(0,1);
```

除了正确生成在指定范围内的数之外，新标准库的领域给优势是可以生成非均匀分布的随机数。

我们注意到有一个分布不接受模板参数，即`bernoulli_distribution`，因为它是一个普通类，而非模板。此分布总是返回一个`bool`值。它返回`true`的概率是要一个常数，此概率的默认值是0.5。

**由于引擎返回相同的随机数序列，所以我们必须在循环外声明引擎对象。否则，每步循环都会创建一个新引擎，从而每步循环都会生成相同的值。类似的，分布对象也要保持状态，因此也应该在循环外定义**

------

## IO库再探

### 格式化输入输出

标准库定义了一组**操纵符（manipulator）**来修改流的格式状态，一个操纵符是一个函数或是一个对象，会影响流的状态，并能用作输入或输出运算符的运算对象。类似输入和输出运算符，操纵符也返回它所处理的流对象，因此我们可以在一条语句中组合操纵符和数据。

操纵符用于两大类输出控制：控制数值的输出形式以及控制补白的数量和位置。大多数改变格式状态的操纵符都是设置/复原成对的；一个操纵符用来将格式状态设置为一个值，而另一个用来将其复原，恢复为正常的默认格式。

**Warning：当操纵符改变流的格式状态时，通常改变后的状态对所有后续IO都生效**

#### 控制布尔值的格式

操纵符改变对象的格式状态的一个例子是`boolalpha`操纵符。默认情况下，`bool`值打印为1或0。一个`true`值输出为整数1，而`false`值输出为0。我们可以通过对流使用`boolalpha`操纵符来覆盖这种格式。

#### 在输出中指出进制

默认情况下，整型值的输入输出使用十进制。我们可以使用操纵符`hex`、`oct`、和`dec`将其改为十六进制、八进制或是改回十进制。

当对流应用`showbase`操纵符时，会在输出结果中显示进制，它遵循与整型常量中指定进制相同的规范：

* 前导0x表示十六进制
* 前导0表示八进制
* 无前导字符串表示十进制

操纵符`noshowbase`恢复`cout`的状态，从而不再显示整型值的进制。

默认情况下，十六进制值会以小写打印，前导字符也是小写的`x`。我们可以通过使用`uppercase`操纵符来输出大写的`X`并将十六进制数字`a-f`以大写输出。我们使用操纵符`nouppercase`、`noshowbase`和`dec`来重置流的状态。

#### 控制浮点数格式

我们可以控制浮点数输出三各种格式：

* 以多高精度（多少个数字）打印浮点值
* 数值是打印位十六进制、定点十进制还是科学记数法形式
* 对于没有小数部分的浮点值是否打印小数点

默认情况下，浮点值按六位数字精度打印；如果浮点值没有小数部分，则不打印小数点；根据浮点数的值选择打印成定点十进制或科学记数法形式。标准库会选择一种可读性更好的格式：非常大和非常小的值打印为科学记数法形式，其他值打印为定点十进制形式。

#### 指定打印精度

默认情况下，精度会控制打印的数字的总数。当打印时，浮点值按当前精度舍入而非截断。我们可以通过调用IO对象的`precision`成员或使用`setprecision`操纵符来改变精度。`precision`成员是重载的。一个版本接受一个`int`值，将精度设置为此值，并返回旧精度值。另一个版本不接受参数，返回当前精度值。`setprecision`操纵符接受一个参数，用来设置精度。

**Note：操纵符`setprecision`和其他接受参数的操纵符都定义在头文件`iomanip`中**

#### 指定浮点数记数法

通过使用恰当的操纵符，我们可以强制一个流使用科学记数法、定点十进制或是十六进制记数法。操纵符`scientific`改变流的状态来使用科学记数法。操纵符`fixed`改变流的状态来使用定点十进制。

在新标准库中，通过使用`hexfloat`也可以强制浮点数使用十六进制格式。新标准库还提供另一个名为`defaultfloat`的操纵符，它将流恢复到默认状态——根据要打印的值选择记数法。

在执行`scientific`、`fixed`或`hexfloat`后，精度控制的是小数点后面的数字位数，而默认情况下精度值指定的是字的总位数——既包括小数点之后的数字也包括小数点之前的数字。

#### 打印小数点

默认情况下，当一个浮点值的小数部分为0时，不显示小数点。`showpoint`操纵符强制打印小数点。

#### 输出补白

当按列打印数据时，我们常常需要非常惊喜地控制数据格式。标准库提供了一些操纵符帮助我们完成所需的控制：

* `setw`指定下一个数字或字符串值的最小空间
* `left`表示左对齐输出
* `right`表示右对齐输出，右对齐是默认格式
* `internal`控制负数的符号的位置，它左对齐符号，右对齐值，用空格填满所有中间空间
* `setfill`允许指定一个字符代替默认的空格来补白输出

#### 控制输入格式

操纵符`noskipws`会令输入运算符读取空白符，而不是跳过它们。为了恢复默认行为，我们可以使用`skipws`操纵符。

------

### 未格式化的输入/输出操作

标准库还提供了一组低层操作，支持**未格式化IO（unformatted IO）**。这些操作允许我们将一个流当作一个无解释的字节序列来处理。

#### 单字节操作

有几个未格式化操作每次一个字节地处理流，它们会读取而不是忽略空白符。例如，我们可以使用未格式化IO操作`get`和`put`来读取和写入一个字符。

#### 将字符放回输入流

有时我们需要读取一个字符才能知道还未准备好处理它。在这种情况下，我们希望将字符放回流中。标准库提供了三种方法退回字符，它们有着细微地差别：

* `peek`返回输入流中下一个字符地副本，但不会将它从流中删除，`peek`返回的值仍然留在流中
* `unget`使得输入流向后移动，从而最后读取的值又回到流中。即使我们不知道最后从流中读取什么值，仍然可以调用`unget`
* `putback`是更特殊版本的`unget`：它退回从流中读取的最后一个值，但它接受一个参数，此参数必须与最后读取的值相同

#### 从输入操作返回的int值

返回`int`的函数将它们要返回的字符先转换为`unsigned char`，然后再将结果提升到`int`。因此，即使字符集中有字符映射到负值，这些操作返回的`int`也是正值。而标准库使用负值表示文件尾，这样就可以保证与任何合法字符的值都不同。头文件`cstdio`定义了一个名为`EOF`的`const`，我们可以用它来检测从`get`返回的值是否是文件尾，而不必记忆表示文件尾的实际数值。

