# 异常处理

**异常处理（exception handling）**机制允许程序中独立开发的部分能够在运行时就出现的问题进行通信并做出相应的处理

### 抛出异常

在C++语言中，我们通过**抛出（throwing）**一条表达式来**引发（raised）**一个异常。被抛出的表达式的类型以及当前的调用链共同决定了哪段**处理代码（handler）**将被用来处理该异常。被选中的处理代码是在调用链中与抛出对象类型匹配的最近的处理代码。

当执行一个`throw`时，跟在`throw`后面的语句将不再被执行。相反，程序的控制权从`throw`转移到与之匹配的`catch`模块。该`catch`可能是同一个函数中的局部`catch`，也可能位于直接或间接调用了发生异常的函数的另一个函数中。控制权从一处转移到另一处，这有两个含义：

* 沿着调用链的函数可能会提早退出
* 一旦程序开始执行异常处理代码，则沿着调用链创建的对象将被销毁

#### 栈展开

当抛出一个异常后，程序暂停当前函数的执行过程并立即开始寻找与异常匹配的`catch`子句。当`throw`出现在一个**`try`**语句块**（try block）**内时，检查该`try`块关联的`catch`子句。如果找到了匹配的`catch`，就是用该`catch`处理异常。如果这一步没找到匹配的`catch`子句且该`try`语句嵌套在其他`try`块中，则继续检查与外层`try`匹配的`catch`子句。如果还是找不到匹配的`catch`，则退出当前的函数，在调用当前函数的外层函数中继续寻找。

上述过程被称为**栈展开（stack unwinding）**。栈展开过程沿着嵌套函数的调用链不断查找，直到找到了与异常匹配的`catch`子句为止；或者也可能一直没找到匹配的`catch`，则退出主函数后查找过程终止。

如果没找到匹配的`catch`子句，程序将退出。因为异常通常被认为是妨碍程序正常执行的事件，所以一旦引发了某个异常，就不能对它置之不理。当找不到匹配的`catch`时，程序将调用标准库函数**`terminate`**，顾名思义，`terminate`负责终止程序的执行过程。

**Note：一个异常如果没有被捕获，则它将终止当前的程序**

### 析构函数与异常

出于栈展开可能使用析构函数的考虑，析构函数不应该抛出不能被它自身处理的异常。换句话说，如果析构函数需要执行某个可能抛出异常的操作，则该操作应该被放置到一个`try`语句块当中，并且在析构函数内部得到处理。

**Warning：在栈展开的过程中，运行类类型的局部对象的析构函数。因为这些析构函数是自动执行的，所以它们不应该抛出异常。一旦在栈展开的过程中析构函数抛出了异常，并且析构函数自身没能捕获到该异常，则程序将被终止**

### 异常对象

**异常对象（exception object)**是一种特殊的对象，编译器使用异常抛出表达式来对异常对象进行拷贝初始化。因此，`throw`语句中的表达式必须拥有完全类型。而且如果该表达式是类类型的话，则相应的类必须含有一个可访问的析构函数和一个可访问的拷贝或移动构造函数。如果该表达式是数组类型或函数类型，则表达式将被转换成与之对应的指针类型。

------

### 捕获异常

**`catch`子句（catch clause）**中的**异常声明（exception declaration）**看起来像是只包含一个形参的函数形参列表。

声明的类型决定了处理代码所能捕获的异常类型。这个类型必须是完全类型，它可以是左值引用，但不能是右值引用。

如果`catch`的参数是基类类型，则我们可以使用其派生类类型的异常对象对其进行初始化。此时，如果`catch`的参数是非引用类型，则异常对象将被切掉一部分，这与将派生类对象以值传递的方式传给一个普通函数差不多。另一方面，如果`catch`的参数是基类的引用，则该参数将以常规方式绑定到异常对象上。

异常声明的静态类型将决定`catch`语句所能执行的操作。如果`catch`的参数是基类类型，则`catch`无法使用派生类特有的任何成员。

#### 查找匹配的处理代码

越是专门的`catch`越应该置于整个`catch`列表的前端。

绝大多数类型的转换都不被允许，除了一些极细小的差别之外，要求异常的类型和`catch`声明的类型是精准匹配的：

* 允许从非常量向常量的类型转换，也就是说，一条非常量对象的`throw`语句可以匹配一个接受常量引用的`catch`语句
* 允许从派生类向基类的类型转换
* 数组被转换成指向数组（元素）类型的指针，函数被转换成指向该函数类型的指针

除此之外，包括标准算术类型转换和类类型转换在内，其他所有转换规则都不能在匹配`catch`的过程中使用。

#### 重新抛出

一条`catch`语句通过**重新抛出（rethrowing）**的操作将异常传递给另外一个`catch`语句。这里的重新抛出仍然是一条`throw`语句，只不过不包含任何表达式。

一个重新抛出语句并不指定新的表达式，而是将当前的异常对象沿着调用链向上传递。

#### 捕获所有异常的处理代码

为了一次性捕获所有异常，我们是用省略号作为异常声明，这样的处理代码称为**捕获所有异常（catch-all）**的处理代码，形如`catch(...)`。一条捕获所有异常的语句可以与任意类型的异常匹配。

------

要想处理构造函数初始值抛出的异常，我们必须将构造函数写成**函数`try`语句块**（也称为函数测试块，function try block）的形式。函数`try`语句块是的一组`catch`语句既能处理构造函数体（或析构函数体），也能处理构造函数的初始化过程（或析构函数的析构过程）。

注意：关键字`try`出现在表示构造函数初始值列表的冒号以及表示构造函数体（此列为空）的花括号之前。与这个`try`关联的`catch`既能处理构造函数体抛出的异常，也能处理成员初始化列表抛出的异常。

在C++11新标准中，我们可以通过提供**`noexcept`**说明（noexcept specification）指定某个函数不会抛出异常。其形式是关键字`noexcept`紧跟在函数的参数列表后面，用以标识该函数不会抛出异常：

```c++
void recoup(int) noexcept;
void alloc(int);
```

对于一个函数来说，`noexcept`说明要么出现在该函数的所有声明语句和定义语句中，要么一次也不出现。该说明应该在函数的尾置返回类型之前。我们也可以在函数指针的声明和定义中指定`noexcept`。在`typedef`或类型别名中则不能出现`noexcept`。在成员函数中，`noexcept`说明符需要跟在`const`及引用限定符之后，而在`final`、`override`或虚函数的=0之前。

`noexcept`说明符接受一个可选的实参，该实参必须能转换成`bool`类型：如果实参是`true`，则函数不会抛出异常；如果实参是`false`，则函数可能抛出异常。

`noexcept`说明符的实参常常与**`noexcept`运算符**（noexcept operator）混合使用。`noexcept`运算符是一个一元运算符，它的返回值是一个`bool`类型的右值常量表达式，用于表示给定的表达式是否会抛出异常。和`sizeof`类似，`noexcept`也不会求其运算对象的值。

函数指针及该指针所指的函数必须具有一致的异常说明。也就是说，如果我们为某个指针做了不抛出异常的声明，则该指针将只能指向不抛出异常的函数。相反，如果我们显式或隐式说明了指针可能抛出异常，则该指针可以指向任何函数，即使是承诺了不抛出异常的函数也可以。

如果一个虚函数承诺了它不会抛出异常，则后续派生出来的虚函数也必须做出同样的承诺；与之相反，如果基类的虚函数允许抛出异常，则派生类的对应函数既可以允许抛出异常，也可以允许不抛出异常。

------

## 命名空间

**多个库将名字放置在全局命名空间中将引发*命名空间污染（namespace pollution）***

**命名空间（namespace）**为防止名字冲突提供了更加可控的机制。命名空间分割了全局命名空间，其中每个命名空间是一个作用域。通过在某个命名空间中定义库的名字，库的作者（以及用户）可以避免全局名字固有的限制。

一个命名空间的定义包含两部分：首先是关键字`namespace`，随后是命名空间的名字，在命名空间后面是一系列由花括号括起来的声明和定义。只要能出现在全局作用域中的声明就能置于命名空间内，主要包括：类、变量（及其初始化操作）、函数（及其定义）、模板和其他命名空间：

```c++
namespace cpluscplus_primer{
	//...
}
```

**Note：命名空间作用域后无须分号**

和其他作用域类似，命名空间中的每个名字都必须表示该空间内的唯一实体。因为不同命名空间的作用域不同，所以在不同命名空间内可以有相同名字的成员。

定义在某个命名空间中的名字可以被该命名空间内的其他成员直接访问，也可以被这些成员内嵌作用域中的任何单位访问。位于该命名空间之外的代码则必须指出所用的名字属于哪个命名空间。

命名空间可以是不连续的，可以定义在几个不同的部分。命名空间的组织方式类似于我们管理自定义类及函数的方式：

* 命名空间的一部份成员的作用是定义类，以及声明作为类接口的函数及对象，则这些成员应该置于头文件中，这些头文件将被包含在使用了这些成员的文件中
* 命名空间成员的定义部分则置于另外的源文件中

有一点需要注意，在通常情况下，我们不把`#include`放在命名空间内不。如果我们这么做了，隐含的意思是把头文件中所有的名字定义成该命名空间的成员。

模板特例化必须定义在原始模板所属的命名空间中。和其他命名空间名字类似，只要我们在命名空间中声明了特例化，就能在命名空间外部定义它了。

全局作用域中定义的名字也就是定义在**全局命名空间（global namespace）**中。全局命名空间以隐式的方式声明，并且在所有程序中都存在。全局作用域中定义的名字被隐式地添加到全局命名空间中。作用域运算符同样可以用于全局作用域的成员，一位内全局作用域是隐式的，所以它并没有名字。

嵌套的命名空间同时是一个嵌套的作用域，它嵌套在外层命名空间的作用域中。嵌套的命名空间中的名字遵循的规则与往常类似：内层命名空间声明的名字将隐藏外层命名空间声明的同名成员。在嵌套的命名空间中定义的名字只在内层命名空间中有效，外层命名空间中的代码要想访问它必须在名字前添加限定符。

C++11新标准引入了一种新的嵌套命名方式，称为**内联命名空间（inline namespace）**。和普通的嵌套命名空间不同，内联命名空间中的名字可以被外层空间直接使用。也就是说，我们无须在内联命名空间的名字前添加该命名空间的前缀，通过外层命名空间的名字就可以直接访问它。定义内联命名空间的方式是在关键字`namespace`前添加关键字`inline`。关键字`inline`必须出现在命名空间第一次定义的地方，后续再打开命名空间的时候可以写`inline`，也可以不写。

**未命名的命名空间（unnamed namespace）**是指关键字`namepsace`后面紧跟花括号括起的一系列声明语句，未命名的命名空间中定义的变量拥有静态生命周期，他们在第一次使用前创建，直到程序结束时才销毁。

------

### 使用命名空间成员

**命名空间的别名（namespace alias）**使得我们可以为命名空间的名字设定一个短得多的同义词：

```c++
namespace cplusplus_primer{/*...*/};
namespace primer = cplusplus_primer;
```

命名空间的别名声明以关键字`namespace`开始，后面是别名所用的名字、=符号、命名空间原来的名字以及一个分号。不能在命名空间还没有定义前就声明别名，否则将产生错误。命名空间的别名也可以指向一个嵌套的命名空间。

**Note：一个命名空间可以有好几个同义词或别名，所有别名都与命名空间原来的名字等价**

一个**`using`声明（using declaration）**语句一次只引入命名空间的一个成员。它使得我们可以清楚地知道程序所用的到底是哪个名字。`using`名字引入地名字遵守与过去一样的作用域规则：它的有效范围从`using`声明开始的地方开始，一直到`using`声明所在的作用域结束为止。

**`using`指示（using directive）**和`using`声明类似的地方是，我们可以使用命名空间名字的简写形式；和`using`声明不同的地方是，我们无法控制哪些名字是可见的，因为所有名字都是可见的。`using`指示以关键字`using`开始，后面是关键字`namespace`以及命名空间的名字。

------

## 多重继承和虚继承

**多重继承（multiple inheritance）**是指从多个直接基类中产生派生类的能力。

在多重继承关系中，派生类的对象包含有每个基类的子对象。

#### 构造一个派生类对象初始化所有基类

构造一个派生类对象将同时构造并初始化它的所有基类子对象。派生类的构造函数初始值列表将实参分别传递给每个直接基类。其中基类的构造顺序与派生列表中基类的出现顺序保持一致，而与派生类构造函数初始值列表中基类的顺序无关。在C++11新标准中，允许派生类从它的一个或几个基类中继承构造函数。但是如果从多个基类中继承了相同的构造函数（即形参列表完全相同），则程序将产生错误。

#### 析构函数与多重继承

和往常一样，派生类的析构函数只负责清除派生类本身分配的资源，派生类的成员及基类都是自动销毁的。合成的析构函数体为空。

#### 多重继承的派生类的拷贝与移动操作

与只有一个基类的继承一样，多重继承的派生类如果定义了自己的拷贝/赋值构造函数和赋值运算符，则必须在完整的对象上执行拷贝、移动或赋值操作。只有当派生类使用的是合成版本的拷贝、移动或赋值成员时，才会自动对其基类部分执行这些操作。在合成的拷贝控制成员中，每个基类分别使用自己的对应成员隐式地完成构造、赋值或销毁等工作。

我们可以令某个可访问基类地指针或引用直接指向一个派生类对象。

### 多重继承下的类作用域

在只有一个基类的情况下，派生类的作用域嵌套在直接基类和间接基类地作用域中。查找过程沿着继承体系自底向上进行，直到找到所需的名字。派生类地名字将隐藏基类地同名成员。

在多重继承的情况下，相同的查找过程在所有直接基类中同时进行。如果名字在多个基类中都被找到，则对该名字的使用将具有二义性。

### 虚继承

尽管在派生列表中同一个基类只能出现一次，但实际上派生类可以多次继承同一个类。派生类可以通过它的两个直接基类分别继承同意给间接基类，也可以直接继承某个基类，然后通过另一个基类再一次间接继承该类。

在默认情况下，派生类中含有继承链上每个类对应的子部分。如果某个类在派生过程中出现了多次，则派生类中将包含该类的多个子对象。

**虚继承（virtual inheritance）**的目的是令某个类做出声明，承诺愿意共享它的基类。其中，共享的基类子对象称为**虚基类（virtual base class）**。在这种机制下，不论虚基类在继承体系中出现了多少次，在派生类中都只包含唯一一个共享的虚基类子对象。

我们指定虚基类的方式是在派生列表中添加关键字`virtual`。

如果虚基类的成员只被一条派生路径覆盖，则我们仍然可以直接访问这个被覆盖的成员。但是如果成员被多于一个基类覆盖，则一般情况下派生类必须为该成员自定义一个新的版本。

#### 虚继承的对象的构造方式

含有虚基类的对象的构造顺序与一般的顺序稍有区别：首先使用提供给最低层派生类构造函数的初始值初始化该对象的虚基类子部分，接下来按照直接基类在派生列表中出现的次序依次对其进行初始化。