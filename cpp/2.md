1.1可寻址的最小内存块称为“字节（byte）”，存储的基本单元称为“字（word）”，它通常由几个字节组成。

1.2类型决定了数据所占的比特数以及该如何解释这些比特的内容。

1.3.1当我们把一个浮点数赋给浮点类型时，进行了近似处理。结果值将仅保留浮点数中小数点之前的部分。

1.3.2当我们把一个整数值赋给浮点类型时，小数部分记为0.如果该整数所占的空间超过了浮点类型的容量，精度可能有损失。

1.3.3当我们赋给无符号类型一个超出它表示范围的值时，结果是初始值对无符号类型表示数值总数取模后的余数。 *example：把-1赋给8比特大小的`unsigned char`所得的结果是255*。

1.3.4当我们赋给带符号类型一个超出它表示范围的值时，结果时**未定义的（undefined）**。

1.3.5当在程序的某处使用了一种算术类型的值而其实所需的时另一种类型的值时，编译器同样会执行上述的类型转换。

Note：切勿混用带符号类型和无符号类型。

1.4浮点型字面值表现为一个小数或以科学计数法表示的指数，其中指数部分用E或e标识。 *example：3.14159   3.14159E0   0.    0e0      .001*。

1.5.1字符串字面值的类型实际上是由常量字符构成的**数组（array）**。

1.5.2编译器在每个字符串的结尾处添加一个空字符（'\0'），因此，字符串字面值的实际长度要比它的内容多1。

1.5.3如果两个字符串字面值位置紧邻且仅由空格、缩进和换行符分隔，则他们实际上是一个整体。

1.6转义序列均以反斜线作为开始

1.7通过添加前缀和后缀，可以改变整型、浮点型和字符型字面值的默认类型。

1.8 `nullptr`是指针字面值。

2.1通常情况下，对象是指一块能存储数据并具有某种类型的内存空间。

2.2在同一条定义语句中，可以用先定义的变量值去初始化后定义的其他变量。

2.3在C++语言中，初始化和赋值是两个完全不同的操作。

Warning：初始化不是赋值，初始化的含义是创建变量是赋予其一个初始值，而赋值的含义是把对象的当前值擦除，而以一个新值来替代。

2.4.1用花括号来初始化变量被称为列表初始化。 example：int units_sold = {0};

2.4.2如果我们使用列表初始化且初始值存在丢失信息的风险，则编译器将报错。

2.5定义于任何函数体之外的变量被初始化为0。一种例外情况是，定义在函数体内部的内置类型变量将不被初始化（uninitialized）。一个未被初始化的内置类型变量是未定义的，如果试图拷贝或以其他形式访问此类型将引发错误。

提示：未初始化变量引发运行时故障。

2.6.1**声明（declaration）**使得名字为程序所知，一个文件如果想使用别处定义的名字则必须包含对那个名字的声明。

2.6.2**定义（definition）**负责创建与名字关联的实体。

2.7.1如果想声明一个变量而非定义它，就在变量名前添加关键字`extern`，而且不要显式地初始话变量。

2.7.2在函数体内部，如果试图初始化一个由`extern`关键字标记的变量，将引发错误。

Note：变量能且只能被定义一次，但是可以被多次声明。

2.8 C++是一种**静态类型（statically typed）**语言，其含义实在编译阶段检查类型。其中检查类型的过程称为类型检查（type checking）。

2.9.1 C++的**标识符（identifier）**由字母、数字和下划线组成，其中必须以字母或下划线开头。标识符的长度没有限制，但是对大小写字母敏感。

2.9.2用户自定义的标识符中不能连续出现两个下划线，也不能以下划线紧连大写字母开头。此外，定义在函数体外的标识符不能以下划线开头。

建议：当你第一次使用变量时再定义它。

2.10作用域中一旦声明了某个名字，它所嵌套着的所有作用域中都能访问该名字。同时，允许在内层作用域中重新定义外层作用域已有的名字。

Warning：如果函数有可能用到某全局变量，则不宜再定义一个同名的局部变量。

3.1**引用（reference）**为对象起了另外一个名字，**引用类型引用（refer to）**另外一种类型。通过将声明符写成&d的形式来定义引用类型，其中d是声明的变量名。

3.2定义引用时，程序把引用和它的初始值绑定（bind）在一起而不是将初始值拷贝给引用。因为无法令引用重新绑定到另外一个对象，因此引用必须初始化。

Note：引用并非对象，相反的，它只是为一个已经存在的对象所起的另外一个名字。

3.3定义了一个引用之后，对其进行的所有操作都是在与之绑定的对象上进行的。

3.4因为引用本身不是一个对象，所以不能定义引用的引用。

3.5.1指针（pointer）是“指向（point to）”另外一种类型的复合类型。

3.5.2指针本身就是一个对象，允许对指针赋值和拷贝，而且在指针的生命周期内它可以先后指向几个不同的对象。

3.5.3指针无须再定义时赋值。和其他内置类型一样，在块作用域内定义的指针如果没有被初始化，也将拥有一个不确定的值。

3.6定义指针类型的方法将声明符写成*d的形式，其中d是变量名。

3.7指针存放某个对象的地址，要想获取该地址，需要使用取地址符（操作符&）。

3.8因为引用不是对象，没有实际地址，所以不能定义指向引用的指针。

指针的值（即地址）应属下列4种状态之一：1.指向一个对象；2.指向紧邻对象所占空间的下一个位置；3.空指针，意味着指针没有指向任何对象；4.无效指针，也就是上述情况之外的其他值。

3.9试图拷贝或以其他方式访问无效指针的值都将引发错误。编译器并不负责检查此类错误。

3.10如果指针指向了一个对象，则允许使用解引用符（操作符*）来访问该对象。

3.11得到空指针最直接的方法就是用字面值`nullptr`来初始化指针。

建议：初始化所有指针。

3.12赋值永远改变的是等号左侧的对象。

3.13一个指针指向某对象，同时另一个指针指向另外对象的下一个地址，此时也有可能出现这两个指针值相等的情况，即指针相等。

3.14.1void*是一种特殊的指针类型，可用于存放任意对象的地址。

3.14.2利用void*指针能做的事比较有限：拿它和别的指针比较、作为函数的输入或输出，或者赋给另外一个void*指针。

3.15一般来说，声明符中修饰符的个数并没有限制。以指针为例，指针式内存中的对象，像其他对象一样也有自己的地址，因此允许把指针的地址再存放到另一个指针当中。

**Tip：面对一条比较复杂的指针或引用的声明语句时，从右向左阅读有助于弄清楚它的真实含义。**

1.1因为const对象一旦创建后其值就不能再改变，所以const对象必须初始化。

1.2只能在const类型的对象上执行不改变其内容的操作。

1.3.1默认情况下，const对象被设定为仅在该文件内有效，当多个文件中出现了同名的const变量时，其实等同于在不同文件中分别定义了独立的变量。

1.3.2只在一个文件中定义const，而在其他多个文件中声明并使用它的解决方法是：对于const变量不管是声明还是定义都添加extern关键字，这样就只需定义一次就可以了

**Note：如果想在多个文件之间共享const对象，必须在变量的定义之前添加extern关键字。**

1.4在初始化常量引用时允许用任意表达式作为初始值，只要该表达式的结果能转换成引用的类型即可，允许为一个常量引用绑定非常量的对象、字面值，甚至是一个一般表达式。

1.5**临时量（temporary**）对象就是当编译器需要一个空间来暂存表达式的求值结果时创建的一个未命名的对象。

1.6常量引用仅对引用可参与的操作做出了限定，对于引用的对象本身是不是一个常量未作限定。因为对象也可能是个非常量，所以允许通过其他途径改变它的值。

1.7**指向常量的指针（pointer to const）**不能用于改变所指对象的值。要想存放常量对象的地址，只能使用指向常量的指针。

1.8**常量指针（const pointer**）必须初始化，而且一旦初始化完成，则它的值（也就是存放在指针中的那个地址）就不能再改变了。

1.9.1**顶层const（top-level const）**表示指针本身是个常量。**底层const（low-level const**）表示指针所指的对象是一个常量。

1.9.2用于声明引用的const都是底层const

1.9.3当执行对象的拷贝操作时，常量是顶层const还是底层const区别明显。其中顶层const不受什么影响，执行拷贝操作并不会改变被拷贝对象的值，因此，拷入和拷出的对象必须具有相同的底层const资格，或者两个对象的数据类型必须能够转换。

1.10 C++11新标准规定，允许将变量声明为**constexpr**类型以便由编译器来验证变量的值是否是一个常量表达式。声明为constexpr的变量一定是一个常量，而且必须用常量表达式初始化。

**Best Practices：一般来说，如果你认定变量是一个常量表达式，那就把它声明成constexpr类型。**

1.11一个constexpr指针的初始值必须是nullptr或者0，或者是存储于某个固定地址中的对象。

1.12函数体内定义的变量一般来说并非存放在固定地址中，因此constexpr指针不能指向这样的变量。相反的，定义于所有函数体之外的对象其地址固定不变，能用来初始化constexpr指针。

1.13在constexpr声明中如果定义了一个指针，限定符constexpr仅对指针有效，与指针所指的对象无关。

2.1.1类型别名（type alias）是一个名字，它是某种类型的同义词。

2.1.2传统的方法是使用关键字**typedef**  *example：typedef double wages //wages是double的同义词*

2.1.3新标准规定了一种新的方法，使用**别名声明（alias declaration）**来定义类型的别名，这种方法用关键字using作别名声明的开始，其后紧跟别名和等号，其作用是把等号左侧的名字规定成等号右侧类型的别名。

2.2如果某个类型别名指代的是复合类型或常量，那么把它用到声明语句里就会产生意想不到的后果。

3.1 C++11新标准引入了**auto**类型说明符，让编译器通过初始值来推算变量的类型。显然，auto定义的变量必须有初始值。

3.2使用auto也能在一条语句中声明多个变量。因为一条声明语句只能由一个基本数据类型，所以该语句中所有变量的初始基本数据类型都必须一样。

3.3 auto一般会忽略掉顶层const，同时底层const则会保留下来。如果希望推断出的auto类型是一个顶层const，需要明确指出。 *example：const auto f = ci*

3.4.1 C++11新标准引入了第二种类型说明符**decltype**，它的作用是选择并返回操作数的数据类型。

3.4.2如果decltype使用的表达式时一个变量，则decltype返回该变量的类型（包括顶层const和引用在内）

3.4.3如果decltype使用的表达式不是一个变量，则decltype返回表达式结果对应的类型。

3.4.4如果表达式的内容时解引用操作，则decltype将得到引用类型。

3.4.5如果decltype使用的是一个不加括号的变量，则得到的结果就是该变量的类型；如果给变量加上了一层或多层括号，编译器就会把它当成是一个表达式。变量是一种可以作为赋值语句左值的特殊表达式，所以这样的decltype就会得到引用类型。

**Warning：切记：decltype((variable))（注意时双层括号）的结果永远是引用，而decltype(variable)结果只有当variable本身就是一个引用时才是引用。**

4.1类内部定义的名字必须唯一，但是可以与类外部定义的名字重复。

4.2类体右侧的表示结束的花括号后必须写一个分号，这是因为类体后面可以紧跟变量名以示对该类型对象的定义，所以分号必不可少。

4.3 C++11新标准规定，可以为数据成员提供一个**类内初始值（in-class initializer）**。

5.1预处理变量有两种状态：已定义和未定义。**#define**指令把一个名字设定为预处理变量，另外两个指令则分别检查某个指定的预处理变量是否已经定义：**#ifdef**当且仅当变量已定义时为真，**#ifndef**当且仅当变量未定义时为真。一旦检查结果为真，则执行后续操作直至遇到**#endif**指令为止。

**Warning：预处理变量无视C++语言中关于作用域的规则。**

