1.1实参的类型必须与对应的形参类型匹配。函数有几个形参，我们就必须提供相同数量的实参。因为函数的调用规定实参数量应与形参数量一致。所以形参一定会被初始化。

1.2函数的形参列表可以为空，但是不能省略。

1.3函数的返回类型不能是数组类型或函数类型，但可以是指向数组或函数的指针。

1.4在C++语言中，名字有作用域，对象有生命周期。名字的作用域是程序文本的一部分，名字在其中可见。对象的生命周期是程序执行过程中该对象存在的一段时间。

1.5形参和函数体内部定义的变量统称为**局部变量（local variable）**。他们对函数而言是“局部”的，仅在函数的作用域内可见，同时局部变量还会隐藏在外层作用域中同名的其他所有声明中。

1.6形参是一种自动对象。函数开始时为形参申请存储空间，因为形参定义在函数体作用域之内，所以一旦函数终止，形参也就被销毁。

1.7某些时候，有必要令局部变量的生命周期贯穿函数调用及之后的时间。可以将局部变量定义成static类型从而获得这样的对象。**局部静态对象（local static object）**在程序的执行路径第一次经过对象定义语句时初始化，并且知道程序终止才被销毁，在此期间即使对象所在的函数结束执行也不会对它有影响。

1.8如果局部静态变量没有显式的初始值，它将执行值初始化，内置类型的局部静态变量初始化为0。

1.9C++语言支持所谓的分离式编译（separate compilation），分离式编译允许我们把程序分割到几个文件中去，每个文件独立编译。

2.1当形参是引用类型时，我们说它对应的实参被**引用传递（passed by reference）**或者函数被**传引用调用（called by reference）**。和其他引用一样，引用形参也是它绑定的对象的别名。也就是说，引用形参是它对应的实参的别名。

2.2当实参的值被拷贝给形参时，形参和实参是两个相互独立的对象，我们说这样的实参被**值传递（passed by value）**或者函数被**传值调用（called by value）**。

2.3指针的行为和其他非引用类型一样，当执行指针拷贝操作时，拷贝的是指针的值。拷贝之后，两个指针是不同的指针。因为指针使我们可以间接地访问它所指的对象，所以通过指针可以修改它所指对象的值。

2.4因为不能拷贝数组，所以我们无法以值传递的方式使用数组参数。因为数组会被转化成指针，所以当我们为函数传递一个数组时，实际传递的是指向数组的首元素的指针。

2.5管理数组实参的第一种方式要求数组本身包含一个结束标记，使用这种方式的典型示例是C风格字符串。 example：

```c++
void print(const char *cp)
{
 if (cp)
   while (*cp)
       cout << *cp++;
}
```

2.6管理数组实参的第二种技术是传递指向数组首元素和尾后元素的指针，这种方式受到了标准库技术的启发。 example：

```c++
void print(const int *beg, const int *end)
{
   while (beg!=end)
        cout << *beg++ << endl;
}
```

2.7第三种管理数组实参的方法是专门定义一个表示数组大小的形参。 example：

```c++
void print(const int ia[], size_t size)
{
  for (size_t i=0;i!=size;++i) {
        cout << ia[i] <<endl;
 }
}
```

2.8C++语言允许将变量定义成数组的引用，基于同样的道理，形参也可以是数组的引用。此时，引用形参绑定到对应的实参上，也就是绑定到数组上。

**Note：&arr两端的括号必不可少**



**`</strong> <strong>f(int &arr[10]) //错误：将arr声明称了引用的数组 f(int (&are)[10]) //正确：arr是具有10个整数的整型数组的引用</strong> <strong>`**



2.9因为我们处理的是数组的数组，所以首元素本身就是一个数组，指针就是一个指向数组的指针。数组第二维（以及后面所有维度）的大小都是数组类型的一部分，不能省略。

2.10 例如：假定main函数位于可执行文件prog之内，我们可以向程序传递下面的选项：prog -d -o ofile data0 这些命令行选项通过两个（可选的）形参传递给main函数

```c++
int main(int argh,char *argv[]){...}
```

第二个形参argv是一个数组，它的元素是指向C风格字符串的指针；第一个形参argc表示数组中字符串的数量。因为第二个形参是数组，所以main函数也可以定义成：

```c++
int main(int argh,char **argv){...}
```

其中argv指向char*。

当实参传给main函数之后，argv的第一个元素指向程序的名字或者一个空字符串，接下来的元素依次传递命令行提供的实参。最后一个指针之后的元素值保证为0.

Warning:当使用argv中的实参时，一定要记得可选的实参从argv[1]开始；argv[0]保存程序的名字，而非用户输入。

2.11如果函数的实参数量位置但是全部实参的类型都相同，我们可以使用**initializer_list**类型的形参。initializer_list是一种标准库类型，用于表示某种特定类型的值的数组。

2.12和vector一样，initializer_list也是一种模板类型。定义initializer_list对象时，必须说明列表中所含元素的类型。

2.13和vector不一样的是，initializer_list对象中的元素永远是常量值，我们无法改变initializer_list对象中元素的值。

2.14如果想向initializer_list形参中传递一个值的序列。则必须把序列放在一对花括号内：

```c++
if (expected !=actual)
   error_msg({“functionX”,expected,actual});
else 
   error_msg({“functionX”,”okay”});
```

**Warning:省略符形参应该仅仅用于C和C++通用的类型。特别应该注意的是，大多数类类型的对象在传递给省略符形参时都无法正确拷贝。**

2.15省略符形参只能出现在形参列表的最后一个位置，它的形式无外乎以下两种：

```c++
void foo(parm_list,...);
void foo(...);
```

第一种形式指定了foo函数的部分形参的类型，对应于这些形参的实参将会执行正常的类型检查。省略符形参所对应的实参无须类型检查。在第一种形式中，形参声明后面的逗号是可选的。

1.1只要函数的返回类型不是void，则该函数内的每条return语句必须返回一个值。return语句返回值的类型必须与函数的返回类型相同，或者能隐式地转换成函数的返回类型。

**Warning：在含有return语句的循环后面应该也有一条return语句，如果没有的话该程序就是错误的。很多编译器都无法发现此类错误。**

1.2函数完成后，它所占用的存储空间也随之被释放掉。因此，函数终止意味着局部变量地引用将指向不再有效的内存区域。同样，返回局部对象的指针也是错误的。一旦函数完成，局部对象被释放，指针将指向一个不存在的对象。

1.3函数的返回类型决定函数调用是否是左值。调用一个返回引用的函数得到左值，其他返回类型得到右值。可以像使用其他左值那样来使用返回引用的函数的调用。特别是，我们能为返回类型是非常量引用的函数的结果赋值。

1.4C++11新标准规定，函数可以返回花括号包围的值的列表。类似于其他返回结果，此处的列表也用来对函数返回的临时量进行初始化。如果列表为空，临时量执行值初始化；否则，返回的值有函数的返回类型决定。

1.5虽然从语法上来说，要想定义一个返回数组的指针或引用的函数比较烦琐，但是有一些办法可以简化这一任务，其中最直接的办法是使用类型别名。 *example：*

```c++
typedef int arrT[10];
using arrT = int[10];
arrT* func(int i); //func返回一个指向含有10个整数的数组的指针
```

1.6如果我们想定义一个返回数组指针的函数，则数组的维度必须跟在函数名字之后。然而，函数的形参列表也跟在函数名字后面且形参列表应该先于数组的维度。因此，返回数组指针的函数形式如下所示：

```c++
Type (*function(parameter_list))[dimension]
```

1.7**尾置返回类型（trailing return type）**跟在形参列表后面并以一个->符号开头。为了表示函数真正的返回类型跟在形参列表之后，我们在本应该出现返回类型的地方放置一个auto：

```c++
auto func(int i) -> int(*)[10];   //func接受一个int类型的实参，返沪一个指针，该指针指向含有10个整数的数组
```

1.8如果我们知道函数返回的指针将指向哪个数组，就可以使用decltype关键字声明返回类型。 *example：*

```c++
int odd[] = {1,3,5,7,9};
int even[] = {0,2,4,6,8};
decltype(odd) *arrPtr(int i)
{
   return (i%2)?&odd:&even; //返回一个指向数组的指针
```

decltype并不负责把数组类型转换成对应的指针，所以decltype的结果是个数组，要想表示arrPtr返回指针还必须在函数声明时加一个*符号。

2.1如果同一作用域内的几个函数名字相同但形参列表不同，我们称之为**重载（overload）函数。**

2.2不允许两个函数除了返回类型外其他所有的要素都相同。

2.3一个拥有顶层const的形参无法和另一个没有顶层const的形参区分开来。

2.4如果形参是某种类型的指针或引用，则通过区分其指向的是常量对象还是非常量对象可以实现函数重载，此时的const是底层的。

2.5.1当调用重载函数时有三种可能的结果

2.5.2编译器找到一个与实参**最佳匹配（best match）**的函数，并生成调用该函数的代码。

2.5.3找不到任何一个函数与调用的实参匹配，此时编译器发出**无匹配（no match）**的错误信息。

2.5.4有多于一个函数可以匹配，但是每一个都不是明显的最佳选择。此时也将发生错误，称为**二义性调用（ambiguous call）**。

2.6如果我们在内层作用域中声明名字，它将隐藏外层作用域中声明的同名实体。在不同的作用域中无法重载函数名。

**Note：在C++语言中，名字查找发生在类型检查之前。**

1.1某些函数有这样一种形参，在函数的很多次调用中它们都被赋予了一个相同的值，此时，我们把这个反复出现的值称为函数的**默认实参（default argument）。**调用含有默认实参的函数时，可以包含该实参，也可以省略该实参。

1.2一旦某个形参被赋予了默认值，它后面的所有形参都必须有默认值。

1.3如果我们想使用默认实参，只要在调用函数的时候省略该实参就可以了。

1.4函数调用时实参按其位置解析，默认实参负责填补函数调用缺少的尾部实参（靠右侧位置）。

1.5在给定的作用域中一个形参只能被赋予一次默认形参。换句话说，函数的后续声明只能为之前那些没有默认值的形参添加默认实参，而且该形参右侧的所有形参必须都有默认值。

1.6局部变量不能作为默认实参。除此之外，只要表达式的类型能转换成形参所需的类型，该表达式就能作为默认实参。用作默认实参的名字在函数声明所在的作用域内解析，而这些名字的求值过程发生在函数调用时。 *example:*

```c++
string screen(sz= ht(), sz = wd, char = def);
void f2()
{
  def = '*';     //改变默认实参的值
  sz wd =100;    //隐藏了外层定义的wd，但是没有改变默认值
  window = screen();   //调用了screen(ht(),80,'*')
```

 

2.1将函数指定为**内联函数（inline）**，通常就是将它在每个调用点上“内联地”展开。在安徽念书地返回类型前面加上关键字inline，这样就可以将它声明成内联函数了。

2.2**constexpr函数（constexpr function）**是指能用于常量表达式地函数。定义constexpr函数的方法与其他函数类似，不过要遵循几项约定：函数的返回类型及所有形参的类型都得是字面值类型，而且函数体中必须有且只有一条return语句。

2.3constexpr函数体内也可以包含其他语句，只要这些语句在运行时不执行任何操作就行。

2.4我们允许constexpr函数的返回值并非一个常量。

2.5内联函数和constexpr函数通常定义在头文件中。

3.1**assert**是一种**预处理宏（preprocessor marco）**。assert宏使用一个表达式作为它的条件：

```c++
assert(<em>expr</em>);
```

首先对expr求值，如果表达式为假（即0），assert输出信息并终止程序的执行。如果表达式为真（即非0），assert什么也不做。

3.2assert的行为依赖于一个名为NDEBUG的预处理变量的状态。如果定义了NDEBUG，则assert什么也不做。默认状态下没有定义NDEBUG，此时assert将执行运行时检查.我们可以使用一个#define语句定义NDEBUG，从而关闭调试状态。

3.3编译器为每个函数都定义了_ _func_ _,它是const char的一个静态数组，用于存放函数的名字。

_ _FILE_ _存放文件名的字符串字面值

_ _LINE_ _存放当前行号的整型字面值

_ _TIME_ _存放文件编译时间的字符串字面值

_ _DATE_ _存放文件编译日期的字符串字面值

4.1函数匹配的第一步时选定本次调用对应的重载函数集，集合中的函数称为**候选函数（candidate function）**。候选函数具备两个特征：一是与被调用的函数同名，二是其声明在调用点可用。

第二步考察本次提供的实参，然后从候选函数中选出能被这组实参调用的函数，这些新选出的函数称为**可行函数（viable function）**。可行函数也有两个特征：一是其形参数量与本次调用提供的实参数量相等，二是每个实参的类型与对应的形参类型相同，或者能转换成形参的类型。

在使用实参数量初步判别了候选函数后，接下来考察实参的类型是否与形参相匹配。

4.2如果有且只有一个函数满足下列条件，则匹配成功：

该函数每个实参的匹配都不劣于其他可行函数需要的匹配。

至少有一个实参的匹配优于其他可行函数提供的匹配。

4.2为了确定最佳匹配，编译器将实参类型到形参类型的转换划分成几个等级：

4.2.1精确匹配，包括以下情况：

实参类型和形参类型相同

实参从数组类型或函数类型转换成对应的指针类型

向实参添加顶层const或者从实参中删除顶层const

4.2.2通过const转换时显得匹配

4.2.3通过类型提升实现的匹配

4.2.4通过算术类型转换或指针转换实现的匹配

4.2.5通过类类型转换实现的匹配

4.3如果重载函数的区别在于它们的引用类型的形参是否引用了const，或者指针类型的形参是否指向const，则当调用发生时编译器通过实参是否是常量来决定选择哪个函数。

5.1要想声明一个可以指向该函数的指针，只需要用指针替换函数名即可。函数名两端的括号必不可少。

5.2当我们把函数名作为一个值使用时，该函数自动地转换成指针。 *example：*

```c++
pf = lengthCompare;
pf = &lengthCompare;  //等价的赋值语句，pf指向名为lengthCompare的函数
```

此外，我们还能直接使用指向函数的指针调用该函数，无须提前解引用指针。 *example：*

```c++
bool b1 = pf("hello", "goodbye");
bool b2 = (*pf)("hello", "goodbye");
bool b3 = lengthCompare("hello", "goodbye");  //均等价
```

5.3和数组类似，虽然不能定义函数类型的形参，但是形参可以是指向函数的指针。此时，形参看起来是函数类型，实际上却是当成指针使用。我们可以直接把函数作为实参使用，此时它会自动转换成指针。

5.4decltype返回函数类型，此时不会将函数类型自动转换成指针类型。因为decltype的结果是函数类型，所以只有在结果前面加上*才能得到指针。

5.5必须时刻注意的是，和函数类型的形参不一样，返回类型不会自动地转换成指针。我们必须显式地将返回类型指定为指针。

5.6如果我们明确知道返回的函数是哪一个，就能使用decltype简化书写函数指针返回类型的过程。我们显式地加上*以表明我们需要返回指针，而非函数本身。