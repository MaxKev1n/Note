1.1vector ：可变大小数组，支持快速随机访问。在尾部之外的位置插入或删除元素可能很慢

deque ： 双端队列。支持快速随机访问。在头尾位置插入/删除速度很快

list ： 双向链表。只支持双向顺序访问。在list中任何位置进行插入/删除操作速度都很快

forward_list ： 单向链表。只支持单向顺序访问。在链表任何位置进行插入/删除操作速度都很快

array ： 固定大小数组。支持快速随机访问，不能添加或删除元素

string ： 与vector相似的容器，但专门用于保存字符。随机访问快。在尾部插入/删除速度快

2.1一个**迭代器范围（iterator range）**由一对迭代器表示，两个迭代器分别指向同一个容器中的元素或者是尾元素之后的位置（one past the last element）。

2.2这种元素范围被称为**左闭合区间（left-inclusive interval）**，其标准数学描述为[begin, end)。

2.3.1如果begin与end相等，则范围为空。

2.3.2如果begin与end不等，则范围至少包含一个元素，且begin指向该范围中的第一个元素。

2.3.3我们可以对begin递增若干次，使得begin==end。

2.4begin和end有多个版本：带r的版本返回反向迭代器；以c开头的版本则返回const迭代器。

2.5与内置数组一样，标准库array的大小也是类型的一部分。当定义一个array时，除了指定元素类型，还要指定容器大小。 *example：*

```c++
array<int, 42>     //类型为：保存42个int的数组
array<string, 10>  //类型为：保存10个string的数组
```

2.6与其他容器不同，一个默认构造的array是非空的：它包含了与其大小一样多的元素。这些元素都被默认初始化，就像一个内置数组中的元素那样。虽然我们不能对内置数组类型进行拷贝或对象赋值操作，但array并无此限制。 *example：*

```c++
int digs[10] = {0,1,2,3,4,5,6,7,8,9};
int cpy[10] = digs;            //错误：内置数组不支持拷贝或赋值
array<int, 10> digits = {0,1,2,3,4,5,6,7,8,9};
array<int, 10> copy = digits;  //正确：只要数组类型匹配即合法
```

2.7由于右边运算对象的大小可能与左边运算对象的大小不同，因此array类型不支持assign，也不允许用花括号包围的值列表进行赋值。

2.8顺序容器（array除外）还定义了一个名为assign的成员，允许我们从一个不同但相容的类型赋值，或者从容器的一个子序列赋值。assign操作用参数所指定的元素（的拷贝）替换左边容器中的所有元素。

**Warning：由于其旧元素被替代，因此传递给assign的迭代器不能指向调用assign的容器。**

**Note：除array外，swap不对任何元素进行拷贝、删除或插入操作，因此可以保证在常数时间内完成。**

2.9元素不会被移动的事实意味着，除string外，指向容器的迭代器、引用和指针在swap操作之后都不会失效。它们仍指向swap操作之前所指向的那些元素。但是，在swap之后，这些元素已经属于不同的容器了。

2.10关系运算符左右两边的运算对象必须是相同类型的容器，且必须保存相同类型的元素。

2.11.1如果两个容器具有相同大小且所有元素都两两对应相等，则这两个容器相等；否则两个容器不等。

2.11.2如果两个容器大小不同，但较小容器中每个元素都等于较大容器中的对应元素，则较小容器小于较大容器。

2.11.3如果两个容器都不是另一个容器的前缀子序列，则它们的比较结果取决于第一个不相等的元素的比较结果。

1.1除array和forward_list之外，每个顺序容器（包括string类型）都支持push_back。

1.2除了push_back，list、forward_list和deque容器还支持名为push_front的类似操作。此操作将元素插入到容器头部。

1.3insert成员提供了更一般的添加功能，它允许我们在容器中任意位置插入0个或多个元素。vector、deque、list和string都支持insert成员。forward_list提供了特殊版本的insert成员。

**Warning：将元素插入到vector、deque和string中的任何位置都是合法的。然而，这样做可能很耗时。**

1.4新标准引入了三个新成员——emplace_front、emplace和emplacement_back，这些操作构造而不是拷贝元素。在调用emplace_back时，会在容器管理的内存空间中直接创建对象。而调用push_back则会创建一个局部临时对象，并将其压入容器中。emplace函数的参数根据元素类型而变化，参数必须与元素类型的构造函数相匹配。

1.5在容器中访问元素的成员函数（即，front、back、下标和at）返回的都是引用。如果容器是一个const对象，则返回值是const的引用。如果容器不是const的，则返回值是普通引用，我们可以用来改变元素的值。

**Warning：删除deque中除首尾位置之外的任何元素都会使所有迭代器、引用和指针失效。指向vector或string中删除点之后位置的迭代器、引用和指针都会失效。**

1.6我们可以用resize来增大或缩小容器，与往常一样，array不支持resize。如果当前大小大于所要求的大小，容器后部的元素会被删除；如果当前大小小于新大小，会将新元素添加到容器后部。

1.7向容器添加元素后：

1.7.1如果容器是vector或string，且存储空间被重新分配，则指向容器的迭代器、指针和引用都会失效。如果存储空间未重新分配，指向插入位置之前的元素的迭代器、指针和引用仍有效，但指向插入位置之后元素的迭代器、指针和引用将失效。

1.7.2对于deque，插入到除首尾位置之外的任何位置都会导致迭代器、指针和引用失效。如果在首尾位置添加元素，迭代器会失效，但指向存在的元素的引用和指针不会失效。

1.7.3对于list和forward_list，指向容器的迭代器、指针和引用仍有效。

1.8当我们删除一个元素后：

1.8.1对于list和forward_list，指向容器其他位置的迭代器、指针和引用仍有效。

1.8.2对于deque，如果在首尾之外的任何位置删除元素，那么指向被删除元素外其他元素的迭代器、引用或指针也会失效。如果是删除deque的尾元素，则尾后迭代器也会失效，但其他迭代器、引用和指针不受影响；如果是删除首元素，这些也不会受影响。

1.8.3对于vector和string，指向被删元素之前元素的迭代器、引用和指针仍有效。注意：当我们删除元素时，尾后迭代器总是会失效。

**Tip:如果在一个循环中插入/删除deque、string或vector中的元素，不要缓存end返回的迭代器。**

**Note：reserve并不改变容器中元素的数量，它仅影响vector预先分配多大的内存空间。**

2.1容器的size是指它已经保存的元素的数目；而capacity则是在不分配新的内存空间的前提下它最多可以保存多少元素。

1.1通常当我们从一个const char*创建string时，指针指向的数组必须以空字符结尾，拷贝操作遇到空字符时停止。如果我们还传递给构造函数一个计数值，数组就不必以空字符结尾。如果我们未传递计数值且数组也未以空字符结尾，或者给定计数值大于数组大小，则构造函数的行为是未定义的。

1.2substr操作返回一个string，它是原始string的一部分或全部的拷贝。可以传递给substr一个可选的开始位置和计数值。

1.3append操作是在string末尾进行插入操作的一种简写形式。replace操作是调用erase和insert的一种简写形式。

1.4string类提供了6个不同的搜索函数，每个函数都有4个重载版本。每个搜索操作都返回一个string::size_type值，表示匹配发生位置的下标。如果搜索失败，则返回一个名为string::npos的static成员。标准库将npos定义为一个const string::size_type类型，并初始化为值-1。由于npos是一个unsigned类型，此初始值意味着npos等于任何string最大的可能大小。

1.5find函数完成最简单的搜索。它查找参数指定的字符串，若找到，则返回第一个匹配位置的下标，否则返回npos。如果是要搜索第一个不在参数中的字符，我们应该调用find_first_not_of。

1.6rfind成员函数搜索最后一个匹配，即子字符串最靠右的出现位置。

2.1**适配器（adaptor）**是标准库中的一个通用概念。本质上，一个适配器是一种机制，能使某种事物的行为看起来像另外一种事物一样。一个容器适配器接受一种已有的容器类型，使其行为看起来像一种不同的类型。

2.2每个适配器都定义两个构造函数：默认构造函数创建一个空对象，接受一个容器的构造函数拷贝该容器来初始化适配器。所有适配器都要求容器具有添加和删除元素的能力。因此，适配器不能构造在array之上。类似的，我们也不能用forward_list来构造适配器，因为所有适配器都要求容器具有添加、删除以及访问尾元素的能力。

2.2.1stack是要求push_back、pop_back和back操作，因此可以使用除array和forward_list之外的任何容器来构造stack。

2.2.2queue适配器要求back、push_back、front和push_front，因此它可以构造于list或deque之上，但不能记于vector构造。

2.2.3priority_queue除了front、push_back和pop_back操作之外还要求随机访问能力，因此它可以构造于vector或deque之上，但不能基于list构造。

2.3标准库queue使用一种先进先出（first-in，first-out，FIFO）的存储和访问策略。进入队列的对象被放置到队尾，而离开队列的对象则从队首删除。

2.4priority_queue允许我们为队列中的元素建立优先级。新加入的元素会排在所有优先级比它低的已有元素之前。