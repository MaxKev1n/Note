### 关系模型基础

------

**属性：**关系的列命名

**模式：**关系名和其属性集合的组合

**元组：**关系中除含有属性名所在行之外的其他行

**关系实例：**一个给定关系中元组的集合



#### 修改关系模式

*删除某个关系*

```sql
DROP TABLE R;
```



修改操作的语句以关键字***ALTER TABLE***开头其后加上关系的名字，后面可以跟集中选项：

1. ***ADD***后面加上属性名字和数据类型
2. ***DROP***后面加上属性名字



#### 默认值

通常，在任何声明属性和其数据类型的地方，都可以加上保留字***DEFAULT***和一个合适的值。

*当新增属性phone时，可以将它的默认值声明为'unlisted'*

```sql
ALTER TABLE MovieStar ADD phone CHAR(16) DeFAULT 'unlisted';
```



#### 键的声明

1. *PRIMARY KEY*
2. *UNIQUE*



**投影：**这个关系只包含原来关系R中的部分列

**选择：**当选择操作符应用到关系R上时，产生一个关系R的元组的子集合

**笛卡尔积**：关系R和S的笛卡尔积是一个有序对的集合，有序对的第一个元素是关系R中的任何一个元组，第二个元素是关系S中的任何一个元组，表示为$R\times S$

**自然连接：**把在R和S模式中有某共同属性，且此属性有相同的值的元组配对，表示为$R\Join S$

**悬浮元组：**如果一个元组不能和另外关系中的任何一个元组配对的话

**$\theta$连接：**先得到R和S的积，再在得到的关系中寻找满足条件C的元组，$R\Join_C S$

------

#### 关系数据库设计理论

#### 函数依赖

定义：如果R的两个元组在属性$A_1,A_2,...,A_n$上一致，那么必定在其他属性$B_1,B_2,...,B_m$上也一致，记为$A_1A_2...A_n \to B_1B_2...B_m$

如果下列条件满足，就认为一个或多个属性集$\{ A_1,A_2,...,A_n\}$是关系的键

1. 这些属性函数决定关系的所有其他属性
2. 在$\{ A_1,A_2,...,A_n\}$的真子集中，没有一个能函数决定R的所有其他属性



**超键：**一个包含键的属性集

**平凡FD：**平凡FD的右边是左边的子集

如果给定要给FD集合S，则任何和S等价的FD集合都被称为S的基本集

满足下面条件的基本集B被称为关系的**最小化基本集**：

1. B中所有FD的右边均为单一属性
2. 从B中删除任何一个FD后，该集合不再是基本集
3. 对于B中任何一个FD，如果从其左边删除一个或多个属性，B将不再是基本集



**BC范式：**每个非平凡FD的左边都必须是超键，即每个非平凡FD的左边必须包含键

分解步骤：

1. 找出一个BCNF违背式，$A_1A_2..A_n\to B_1B_2...B_m$
2. 将R分解为两个关系，$R1( A_1,A_2,...,A_n,B_1,B_2,...,B_m)$和$R2(A_1,A_2,...,A_n, all\quad the\quad other\quad  attributes\quad of\quad R)$
3.  重复分解步骤，直至所有关系都满足BCNF



**第二范式：**对于任意非平凡函数依赖$A_1A_2...A_n\to B$，若*B*不是键属性，则$A_1A_2...A_n$也不是某个键的真子集

**第三范式：**对于每个非平凡FD，或者其左边是超键，或者其右边仅由主属性构成

**第四范式：**如果对于R中的每个非平凡 $MVD\quad A_1A_2...A_n \to B_1B_2...B_m$，$\{ A_1A_2...A_n\}$都是超键

**多值依赖：**在关系R中，当给定某个属性集合的值时，存在另外一组属性集合，该组属性的值与关系中所有其他属性的值独立，对于R中每个在所有A属性上一致的元组对*t*和*u*，满足

1. 在A属性上的取值与*t*和*u*相同
2. 在B属性上的取值与*t*相同
3. 在R中不属于A和B的所有属性上的取值与*u*相同

------

### 高级数据库模型

#### E/R模型

**实体：**某种抽象对象，相似实体的集合形成实体集

**属性：**实体集有相关的属性，属性是这个实体集中实体所具有的性质

**联系：**两个或多个实体集的连接



* 实体集：矩形

* 属性：椭圆

* 联系：菱形
* 用边来连接实体集与它的属性，同样也用边来连接联系与它的实体集



**如果从实体集E到F是多对一联系，就把箭头指向F。箭头表示实体集E中每个实体与实体集F中的最多一个实体联系。除非还有一个箭头指向E，否则F中的每个实体可以与E中的多个实体联系**

**在多路联系中，指向实体集E的箭头表示：如果从该联系的其他每个实体集中选择一个实体，它们至多与E中的一个实体联系。**

一个实体集中含有一些实体，这些实体拥有集合中其他实体成员没有的特殊性质，可以定义一些特殊实体集或子类。我们用一个被称为$isa$的联系连接实体集和他的子类，使用一种特殊符号即三角形表示，三角形的一边与子类相连，与此边相对的一角与父类相连。

*  每个实体集必须有一个键，尽管在$isa$层次和弱实体集情况下，键实际上是属于另一个实体集
* 一个实体集也可以有多个键

**假设R是从实体集E到实体集F的联系，用圆箭头指向F表示此联系从E到F不仅是多对一或一对一，而且要求与给定的E实体相联系的F实体必须存在。**

**度约束：**在E/R模型中，可以在连接一个联系到一个实体的边上加一个数字，表示相关实体集中任一实体可被联系道德实体数目的约束

**弱实体集：**一个实体集键是由另一个实体集的部分或全部属性构成

* 弱实体集：双矩形
* 多对一的联系：双菱形

------

### 代数和逻辑查询语言

**在基于包的关系当中允许重复元组出现**

关系代数的扩展操作符：

1. 消重复操作符
2. 聚集操作符
3. 分组操作符
4. 扩展投影
5. 排序算子
6. 外连接算符



**外连接：**外连接开始进行的操作是自然连接，然后再把来自R或者S的悬浮元组加入其中，加入的元组用*null*符号补齐那些出现在结果中但不具有值的属性。

**左外连接：**只有左变量R的悬浮元组被补齐

**右外连接：**只有右变量S的悬浮元组被补齐

------

### 约束与触发器

**外键约束：**一个关系中出现的值也必须在另一个关系的主键中出现

**外键声明：**

1. 被引用的另一个关系的属性在它所在的关系中，必须被声明为*UNIQUE*或*PRIMARY KEY*
2. 在第一个关系中出现的外键值，也必须在被引用关系的某个元组的属性中出现

```sql
REFERENCES <表名> (<属性名>)        //外键是单个属性
FOREIGN KEY (<属性名列表>) REFERENCES <表名> (<属性名列表>)       //一组属性是一个外键
```



1. 缺省原则：拒绝违法更新，即拒绝任何违法引用完整性约束的更新
2. 级联原则：在该原则下，被引用属性（组）的改变仿造到外键上
3. 置空性原则：当在被引用的关系上的更新影响外键值时，后者被改为空值

**这些选项可独立地选择删除和修改，并且它们同外键一起声明。生命的方法是在*ON DELETE*或*ON UPDATE*后面加上*SET NULL*或*CASCADE*选项**



#### 属性和元组上的约束

在*CREATE  TABLE*语句上可以声明两种约束：

1. 在单一属性上的约束
2. 在整个元组上的约束



**非空值约束：** *NOT NULL*，其作用是不允许元组的该属性取空值

**基于属性的CHECK约束：**将保留字*CHECK*和用圆括号括起来的条件附加在属性声明上，该条件是该属性的每个值都应满足的条件

**基于元组的CHECK约束：** 在用*CREATE TBALE*语句定义表时，可以在属性列表、键或外键声明上附加*CHECK*保留字，其约束条件用括号括起



为了命名，在约束前加保留字*CONSTRAINT*和该约束的名字

```sql
name CHAR(30) CONSTRAINT NameIsKey PRIMARY KEY
```



#### 触发器

**触发器**有时也称作**事件—条件—动作规则**，或者**ECA规则**

1. 仅当数据库程序员声明的事件发生时，触发器被激活
2. 当触发器被事件激活时，触发器测试触发的条件
3. 如果触发器声明的条件满足，则与该触发器相连的动作由DBMS执行

------

### 视图与索引

#### 虚拟视图

视图定义：*CREATE VIEW <视图名> AS <视图定义>;*

-----

* 事务的原子性：要么都执行，要么都不执行
* 模式匹配：模式*p*中普通字符仅能匹配*s*中与其相同的字符，而*%*能匹配*s*中任何任意长度（包括零长度）的字符串，*p*中的*_*能匹配*s*中任何一个字符
* SQL提供了***GRANT***语句以允许一个用户将权限授权给另一个用户，第一个用户仍然保留了所授予的权限，因此被认为是复制权限。格式如下：*GRANT <权限列表> ON <数据库元素> TO <用户列表>*
* 收权语句的简单形式始于：*REVOKE <权限列表> ON <数据库元素> FROM <用户列表>*   并以*CASCADE*或*RESTRICT*结束
* 关系模式设计不当导致的异常基本类型：**冗余**，**更新异常**，**删除异常**

