## 线索二叉树
若结点有左子树，则其child域指示其左孩子，否则另lchild指向其前驱结点；若结点有右子树，则其rchild指示其右孩子，否则另rchild域指示其后继结点；为了区分结点的指针域是指向孩子还是前驱或后继，在结点中增加两个标志位：ltag和rtag。

#### 森林和二叉树的转换
**森林转换成二叉树：**
1. 将森林中的每棵树转换成相应的二叉树；
2. 第一棵二叉树不动，从第二棵二叉树开始，依次把后一棵二叉树的根结点作为前一棵二叉树根结点的右孩子，当所有的二叉树连起来之后，此时所得到的二叉树就是由森林转换得到的二叉树。

#### 树和二叉树的转换
**树转换成二叉树：**
1. 加线：将树中所有相邻兄弟之间加一条连线
2. 抹线：对树中的每个结点，只保留它与第一个孩子结点之间的连线，删除它与其他孩子结点之间的连线
3. 旋转：以树的根结点为轴心，将整棵树顺时针旋转45，使之成为一棵层次分明的二叉树。

**二叉树转换成树：**
1. 若某结点是双亲的左孩子，则把该结点的右孩子、右孩子的右孩子……都与该结点的双亲结点用线连起来。
2. 删去原二叉树中所有的双亲结点与其右孩子结点的连线。
3. 整理由（1）、（2）两步所得到树或森林，使之结构层次分明。

## 树的遍历
- 先根（先序）
- 后根（后序）

## 哈夫曼树
**路径：**从一个祖先结点到子孙结点之间的分支构成这两个结点间的路径
**路径长度：**路径上的分支数目称为路径长度
**树的路径长度：**从根到每个结点的路径长度之和
**结点的带权路径长度：**从根到该结点的路径长度与该结点权的乘积
**哈夫曼树：**假设有n个权值$(w_1,w_2,...,w_n)$，构造有n个叶子结点的二叉树，每个叶子结点有一个$w_i$作为它的权值，则带权路径长度最小的二叉树称为哈夫曼树

### 哈夫曼树的构造
1. 根据给定的n个权值 ，构造n棵只有一个根结点的二叉树， n个权值分别是这些二叉树根结点的权。设F是由这n棵二叉树构成的集合
2. 在F中选取两棵根结点树值最小的树作为左、右子树，构造一颗新的二叉树，置新二叉树根的权值=左、右子树根结点权值之和
3. 从F中删除这两颗树，并将新树加入F；
4. 重复 2) 和3)，直到F中只含一颗树为止；


# 图
## 图的定义**路径**：在图中由顶点v到v‘的顶点序列
**回路或环**：第一个顶点和最后一个顶点相同的路径
**简单回路或简单环**：除第一个顶点和最后一个顶点外，其余顶点不重复出现的回路
**连通**：顶点v至v’之间有路径存在

**生成树**：极小连通子图。包含图的所有n个结点，但只含图的n-1条边。在生成树中添加一条边之后，必定会形成回路或环。

**完全图**：有n(n-1)/2条边的无向图，其中n是结点个数
**有向完全图**：有n(n-1)条边的有向图
**邻接点**：无向图结点的度；有向图结点的出度和入度
## 图的存储结构
* 邻接矩阵和加权邻接矩阵
* 邻接表
### 邻接矩阵和加权邻接矩阵
**无权值的有向图的邻接矩阵**
设有向图有n个结点，则用n行n列矩阵A表示有向图；如果i至j有一条弧，则A[i,j] =1；否则，A[i,j]=0。注意：A[i,i]=0。出度：i行之和；入度：j列之和
**无权值的无向图的邻接矩阵**
设无向图有n个结点，则用n行n列的矩阵A表示该无向图；如果i至j有一条边,则A[i,j]=1 ；否则，A[i,j]=0。注意：A[i,i] = 0。i结点的度：i行或i列之和。为对称矩阵。
**图的加权邻接矩阵**
设图有n个顶点，则用n行n列的矩阵A表示该图；如果i至j有一条边（弧）且它的权值为w。则 A[i,j]=w ;否则，A[i,j]= ∞ （或其它标志）；
```c++
#define MAXINT  (1<<sizeof(int)*8-1)-1 CreateGraph(a[][VexNuM],e) // VexNuM-图的顶点数,e-边（弧）数   {  for(i=0;i<VexNuM;i++)        for(j=0;j<VexNuM;j++) a[i][j]= MAXINT;   for(k=1;k<=e;k++)    {  cin<<i<<j<<w;//读入顶点号i,j和边上权w       a[i-1][j-1]=w;       a[j-1][i-1]=w;//无向图    }  }```

### 邻接表
设图具有n个结点，则用顶点数组表、边（弧）表表示改有向图或无向图
**数组顶点表中的分量的形式**
`data`：结点的数据域，保存结点的数据值
`firstarc`：结点的指针域，给出自该顶点出发的第一条边（弧）的边结点的地址
**边表中的结点的形式**
`adjvex`：结点的数据域，保存结点的数据（比如顶点号）。`nextvex`：结点的指针域，给出该结点的下一结点（边）的地址。
`info`：边结点的数据域，保存边的 权值等。如不是网，此部分可省去。```c++
void  Create(Graph &G,int n,int e)    //adj：邻接表表头数组， n个顶点,e条弧{   for(i=0;i<n;i++) {     G.adj[i].data=i+1;       G.adj[i].firstarc=NULL;}  for(i=1;i<=e;i++)   { cin>>u>>v;//输入一条弧<u,v>     p =new ArcNode;     p->adjvex=v;     p->nextarc=adj[u-1].firstarc;     G.adj[u-1].firstarc=p;   }}

typedef struct ArcNode{    int adjvex;    ArcNode nextarc;}ArcNode; typedef struct{   int data;  ArcNode *firstarc;}Vexnode;Typedef struct{   Vexnode adj[max];   int n,e;}Graph;  
#define max 20typedef struct ArcNode{    int adjvex;    ArcNode nextarc;}ArcNode; typedef struct{   Telemtype data;  ArcNode *firstarc;}Vexnode;Typedef struct{   Vexnode adj[max];   int n,e;}Graph;
int serach(Graph G,Telemtype e){     for(int i=0;i<G.n;i++)        if(G.adj[i].data==e) return i;          return –1;}


void  Create(Graph &G,int n,int e)    { int h,t;   for(int i=0;i<n;i++) {     cin>> G.adj[i].data;       G.adj[i].firstarc=NULL;}  for(int j=1;j<=e;j++)   { lab:cin>>u>>v;//输入一条弧<u,v>      h=search(G,u);t=search(G,v);      if(h==-1||t==-1){ cout<<“无此顶点“<<endl;                                   goto lab;}      p =new ArcNode;      p->adjvex=t;      p->nextarc=adj[h].firstarc;      G.adj[h].firstarc=p;}}```

## 图的遍历
* 深度优先（DFS）
1）访问顶点v
2）从v的未被访问的邻接点出发，继续对图进行深度优先遍历，若从某点出发所有邻接点都已访问过，退回前一个点继续上述过程，若退回开始点，结束。

* 广度优先（BFS）
1） 访问顶点v ；2）访问同v相邻的所有未被访问的邻接点w1,w2, …wk；3）依次从这些邻接点出发，访问它们的所有未被访问的邻接点; 依此类推，直到图中所有访问过的顶点的邻接点都被访问；

## 生成树和最小生成树
每次遍历一个连通图将图的边分成遍历所经过的边和没有经过的边两部分，将遍历经过的边同图的顶点构成一个子图，该子图称为生成树

### 最小生成树
**定义**：生成树中边的权值之和最小的树
**Kruskal算法**
**Prim算法**
 
## 有向无环图及应用
### 拓扑排序
1. AOV网：用顶点表示活动，边表示活动的优先关系的有向图称为AOV网。AOV网不允许有回路
2. 拓扑有序序列：把AOV网络中各顶点按照它们相互之间的优先关系排列一个线性序列的过程。若$v_i$是$v_j$前驱，则$v_i$一定在$v_j$之前；对于没有优先关系的点，顺序任意。
  
(1)在有向图中选一个没有前驱的顶点且输出之(2)从图中删除该顶点和所有以它为尾的弧
(3)重复上述两步，直至全部顶点均已输出；或者当图中不存在无前驱的顶点为止(此时说明图中有环）

```c++
//NUM:图顶点数，adj：邻接表表头void  topsort(adj){ 初始化栈;   findindegree(adj,indegree);   for(i=0;i<NUM;i++)     if(indegree[i]==0)         push(i);   count=0; while(栈不空） { i=pop();   cout<<i+1;  count++;   for(p=adj[i].firstarc;p!=NULL;p=p->next)    {  k=p->adjvex-1;       indegree[k]--;    if(indegree[k]==0)  push(k); }   } if(count<NUM) cout<<“有回路”<<endl;}```

### 关键路径
**AOE网**：带权的有向无环图，其中顶点表示事件，弧表示活动，权表示活动持续时间。在工程上常用来表示工程进度计划。

**源点**：整个工程的开始点（入度为0）
**汇点**：整个工程的结束点（出度为0）
**活动（有向边）**：它的权值定义为活动进行所需要的时间。方向表示事件的优先关系。
**事件的最早发生时间ve(j)**：从源点到j结点的最长路径
**事件的最迟发生时间vl(j)**：不影响工程的如期完工，事件j必须发生的时间
活动$a_i$由弧<i,j>表示，持续时间记为*dut<j,k>*,则有：
活动的最早开始时间：e(i)=ve(j)
活动的最迟开始时间：l(i)=vl(k_-dut(<j,k>)
**活动余量**：l(i)-e(i)的差
**关键活动**：活动余量为0的活动
**关键路径**：从源点到汇点的最长的一条路径，或者全部由关键活动构成的路径